<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>图片拼接 & 手写签名 - 合并版</title>
    <style>
      :root { --tab-bg: #fff; --tab-text: #222; --tab-muted: #666; --accent: #3a7afe; --border: #e5e7eb; }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Microsoft YaHei", "PingFang SC", sans-serif; background: #f7f7fa; color: var(--tab-text); }
      header { background: var(--tab-bg); border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 10; }
      .tabs { display: flex; gap: 8px; padding: 10px 12px; align-items: center; }
      .tabs .title { font-size: 16px; color: var(--tab-muted); margin-right: 12px; }
      .tab-btn { appearance: none; border: 1px solid var(--border); background: #f0f5ff; color: var(--tab-text); padding: 8px 14px; border-radius: 10px; cursor: pointer; font-size: 14px; transition: all .15s ease; }
      .tab-btn:hover { border-color: #c8ccd3; box-shadow: 0 2px 6px rgba(0,0,0,0.08); transform: translateY(-0.5px); }
      .tab-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 2px 8px rgba(58,122,254,0.35); }
      main { height: calc(100vh - 48px); }
      .frames { height: 100%; }
      .tool-frame { width: 100%; height: 100%; border: 0; display: none; background: #fff; }
      .tool-frame[aria-hidden="false"] { display: block; }
      /* 兼容移动端，防止 100vh 包含地址栏导致溢出 */
      @supports (height: 100dvh) {
        main { height: calc(100dvh - 48px); }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="tabs">
        <span class="title">工具切换：</span>
        <button id="tab-stitch" class="tab-btn active" data-target="stitch">图片拼接工具</button>
        <button id="tab-sign" class="tab-btn" data-target="sign">手写签名PNG</button>
        <button id="tab-compress" class="tab-btn" data-target="compress">图片压缩</button>
        <button id="tab-more" class="tab-btn" data-target="more">更多功能····</button>
      </div>
    </header>
    <main>
      <div class="frames">
        <iframe id="frame-stitch" class="tool-frame" title="图片拼接工具" aria-hidden="false"></iframe>
        <iframe id="frame-sign" class="tool-frame" title="手写签名PNG" aria-hidden="true"></iframe>
        <iframe id="frame-compress" class="tool-frame" title="图片压缩" aria-hidden="true"></iframe>
        <iframe id="frame-more" class="tool-frame" title="更多功能" aria-hidden="true"></iframe>
      </div>
    </main>

    <!-- 内嵌模板：图片拼接工具 -->
    <template id="tpl-stitch"><!-- BEGIN: 图片拼接工具.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>图片拼接工具 - Mr.Chen</title>
  <style>
    :root {
      --bg: #f7f7fa;
      --card: #ffffff;
      --text: #222;
      --muted: #666;
      --accent: #3a7afe;
      --border: #e5e7eb;
      --danger: #d14343;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Microsoft YaHei", "PingFang SC", sans-serif; background: var(--bg); color: var(--text); }
    header { padding: 8px; text-align: center; }
    header h1 { margin: 4px 0 2px; font-size: 20px; }
    header p { margin: 0; color: var(--muted); font-size: 13px; display:none; }

    .container { max-width: 1800px; margin: 0 auto; padding: 8px 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 920px) { .grid { grid-template-columns: 0.7fr 1.3fr; } }
    .column { display: flex; flex-direction: column; gap: 10px; }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    .card h2 { font-size: 16px; margin: 0; padding: 8px 12px 0; }
    .card .content { padding: 10px; }

    .uploader { border: 1px dashed var(--border); border-radius: 8px; padding: 10px; background: #fafafa; }
    .file-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
.file-row input[type="file"] { flex: 1; font-size: 16px; }
.file-row input[type="file"]::file-selector-button,
.file-row input[type="file"]::-webkit-file-upload-button {
  appearance: none;
  border: 1px solid var(--border);
  background: #f0f5ff;
  color: var(--text);
  padding: 10px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all .15s ease;
  box-shadow: 0 1px 1px rgba(0,0,0,0.04);
}
.file-row input[type="file"]::file-selector-button:hover,
.file-row input[type="file"]::-webkit-file-upload-button:hover {
  border-color: #c8ccd3;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  transform: translateY(-0.5px);
}
    .hint { font-size: 12px; color: var(--muted); }

    .canvas-wrap { position: relative; border: 2px solid var(--border); border-radius: 8px; overflow: hidden; background: #fff; }
    /* 仅等比缩小：不放大原始像素尺寸，保持比例 */
    .canvas-wrap canvas { display: block; width: auto; height: auto; max-width: 100%; max-height: 100%; }
    /* 拖拽高亮 */
    .canvas-wrap.dragover { border-color: var(--accent); box-shadow: inset 0 0 0 2px rgba(58,122,254,0.35); background: #f8fbff; }
    .overlay { position: absolute; left: 0; top: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center; }
    .overlay.hidden { display: none; }
    .overlay .hint-box { text-align: center; color: var(--muted); font-size: 13px; background: rgba(255,255,255,0.85); padding: 8px 12px; border-radius: 8px; border: 1px dashed var(--border); }
    /* 全屏拖拽提示层 */
    .page-drag-overlay { position: fixed; z-index: 9999; left: 0; top: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; background: rgba(58,122,254,0.08); }
    .page-drag-overlay .hint-box { text-align: center; color: var(--accent); font-size: 16px; background: rgba(255,255,255,0.92); padding: 12px 16px; border-radius: 10px; border: 2px dashed var(--accent); box-shadow: 0 4px 14px rgba(58,122,254,0.25); }
    .page-drag-overlay .hint-box small { display:block; color: var(--muted); margin-top: 6px; }
    .page-drag-overlay.hidden { display: none; }
    .controls { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin-top: 8px; }
    .controls label { font-size: 13px; color: var(--muted); }
    .controls .inline { display: flex; align-items: center; gap: 8px; }
    /* 去除未使用的滑块样式 */
    .btn { appearance: none; border: 1px solid var(--border); background: #fff; color: var(--text); padding: 8px 12px; border-radius: 10px; cursor: pointer; font-size: 14px; transition: all .15s ease; box-shadow: 0 1px 1px rgba(0,0,0,0.04); }
    .btn:hover { border-color: #c8ccd3; box-shadow: 0 2px 6px rgba(0,0,0,0.08); transform: translateY(-0.5px); }
    .btn:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.06); }
    .btn:focus-visible { outline: 2px solid rgba(58,122,254,0.35); outline-offset: 2px; }
    .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 2px 8px rgba(58,122,254,0.35); }
    .btn-primary:hover { filter: brightness(1.05); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-accent { border-color: var(--accent); color: var(--accent); background: #f0f5ff; }
    .btn-accent:hover { background: #e6eeff; }
    .btn-danger { background: var(--danger); color: #fff; border-color: var(--danger); }

    .settings { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 640px) { .settings { grid-template-columns: 1fr 1fr; } }
    .row { display: flex; align-items: center; gap: 8px; }
    .row input[type="text"] { flex: 1; padding: 8px 10px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; }
    .row .note { font-size: 12px; color: var(--muted); }

    .footer { display: flex; flex-direction: column; gap: 8px; }
    @media (min-width: 640px) { .footer { flex-direction: row; align-items: center; } }
    .msg { font-size: 12px; color: var(--muted); }

    .preview-card { margin-top: 12px; display: flex; flex-direction: column; }
    .preview-card h3 { margin: 0; padding: 12px 12px 0; font-size: 14px; color: var(--muted); }
    .size-line { font-size: 12px; color: var(--muted); padding: 0 12px 12px; }
    /* 右侧预览固定高度，内部自适应缩放 */
    .preview-card .content { display: flex; flex-direction: column; height: 100%; }
    .preview-card .canvas-wrap { flex: 1; background: #fafafa; min-height: 0; display: flex; align-items: center; justify-content: center; }
    .preview-card .canvas-wrap canvas { max-width: 100%; max-height: 100%; }
  </style>
</head>
<body>
  <header>
    <!-- <h1>图片拼接工具</h1> -->
    <p>上传两张图片，支持裁切与旋转；按裁剪后尺寸动态拼接白底JPG并限制≤500KB。</p>
  </header>

  <div class="container">
    <div class="grid">
      <div class="column" id="leftColumn">
      <!-- 左侧编辑器：图片1 -->
      <section class="card" id="editor1">
        <h2>图片一</h2>
        <div class="content">
          <div class="uploader">
            <div class="file-row">
              <input type="file" id="file1" accept="image/*" />
              
            </div>
          </div>
          <div class="canvas-wrap" style="margin-top:6px;">
            <canvas id="canvas1" width="480" height="280"></canvas>
            <div class="overlay" id="overlay1">
              <div class="hint-box">
                <div><strong>拖拽图片到此处</strong></div>
                <div>或点击上方选择</div>
              </div>
            </div>
          </div>
          <div class="controls">
            <div class="inline">
              <label>旋转：当前 <span id="rotVal1">0°</span></label>
<button class="btn btn-accent" id="rotateLeft1">向左旋转90°</button>
<button class="btn btn-accent" id="rotateRight1">向右旋转90°</button>
            </div>
            <button class="btn" id="clearCrop1">清除裁切</button>
          </div>
          
        </div>
      </section>

      <!-- 右侧编辑器：图片2 -->
      <section class="card" id="editor2">
        <h2>图片二</h2>
        <div class="content">
          <div class="uploader">
            <div class="file-row">
              <input type="file" id="file2" accept="image/*" />
              
            </div>
          </div>
          <div class="canvas-wrap" style="margin-top:6px;">
            <canvas id="canvas2" width="480" height="280"></canvas>
            <div class="overlay" id="overlay2">
              <div class="hint-box">
                <div><strong>拖拽图片到此处</strong></div>
                <div>或点击上方选择</div>
              </div>
            </div>
          </div>
          <div class="controls">
            <div class="inline">
              <label>旋转：当前 <span id="rotVal2">0°</span></label>
<button class="btn btn-accent" id="rotateLeft2">向左旋转90°</button>
<button class="btn btn-accent" id="rotateRight2">向右旋转90°</button>
            </div>
            <button class="btn" id="clearCrop2">清除裁切</button>
          </div>
          
        </div>
      </section>
      </div>

      <div class="column">
        <!-- 右侧：拼接预览与下载 -->
        <section class="card preview-card" id="finalCard" style="margin-top:0;">
          <div class="content">
            <div class="settings">
              <div class="row">
                <label for="filename">图片存储名称：</label>
                <input type="text" id="filename" placeholder="拼接图" value="客户姓名 - " />
              </div>
            </div>
            <div class="canvas-wrap" style="margin-top:6px;">
            <canvas id="finalCanvas" width="800" height="600"></canvas>
            </div>
            <div class="footer" style="margin-top:8px;">
              <button class="btn btn-primary" id="downloadBtn" disabled>下载JPG（≤500KB）</button>
              <span class="msg" id="statusMsg">请先上传两张图片并进行裁切/旋转设置。</span>
            </div>
            <div class="size-line" id="sizeLine">当前估算大小：--</div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <!-- 全屏拖拽提示层 -->
  <div id="pageDragOverlay" class="page-drag-overlay hidden">
    <div class="hint-box">
      <div><strong>拖拽图片到页面</strong></div>
      <small>请将图片拖拽到“图片一”或“图片二”的预览区</small>
    </div>
  </div>

  <script>
    // 配置
    const MAX_BYTES = 500 * 1024;
    // 固定边距与间距（无需交互）
    const MARGIN_LR = 40; // 左右边距
    const MARGIN_TB = 40; // 上下边距
    const GAP_VB = 20;    // 两图上下间距

    // 同步右侧预览卡片高度到左列总高度，保证对齐并固定
    function syncRightHeight(){
      const left = document.getElementById('leftColumn');
      const right = document.getElementById('finalCard');
      if (!left || !right) return;
      const h = Math.round(left.getBoundingClientRect().height);
      right.style.height = h + 'px';
    }
    window.addEventListener('load', syncRightHeight);
    window.addEventListener('resize', syncRightHeight);

    // 工具函数
    function dataUrlSizeBytes(dataUrl) {
      try {
        const base64 = dataUrl.split(',')[1] || '';
        return Math.ceil(base64.length * 0.75); // base64长度≈字节数*4/3
      } catch (e) { return Infinity; }
    }
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    // 图像编辑器对象
    function createEditor(cfg) {
      const fileInput = document.getElementById(cfg.fileId);
      const canvas = document.getElementById(cfg.canvasId);
      const ctx = canvas.getContext('2d');
      const dropZone = canvas.parentElement; // 预览区域作为拖拽目标
      const overlay = document.getElementById(cfg.overlayId);
      // 不再使用独立的DOM覆盖层，改为在canvas上绘制裁剪框，避免CSS缩放造成坐标误差
      const rotateVal = document.getElementById(cfg.rotateValId);
      const rotateLeftBtn = document.getElementById(cfg.rotateLeftId);
      const rotateRightBtn = document.getElementById(cfg.rotateRightId);
      const clearCropBtn = document.getElementById(cfg.clearCropId);

      const state = {
        img: null,
        loaded: false,
        angle: 0,
        // 裁切基于原始方向的图像坐标
        crop: null, // {x,y,w,h}
        // 预览绘制信息
        draw: { scale: 1, offsetX: 0, offsetY: 0, centerX: 0, centerY: 0, angleRad: 0 }
      };

      // 统一的文件加载函数（用于文件选择与拖拽）
      function loadFile(file){
        if (!file) return;
        const name = (file.name || '').toLowerCase();
        const isImageViaType = !!file.type && file.type.startsWith('image/');
        const isImageViaName = /(\.png|jpe?g|gif|bmp|webp|heic|heif|tif|tiff|jfif)$/i.test(name);
        if (!isImageViaType && !isImageViaName) {
          // 仍尝试加载，部分浏览器拖拽时 file.type 为空
          // 若确实不是图片，onerror 会提示
        }
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          state.img = img;
          state.loaded = true;
          state.crop = null;
          state.angle = 0;
          rotateVal.textContent = '0°';
          drawPreview();
          updateFinal();
          if (overlay) overlay.classList.add('hidden');
          URL.revokeObjectURL(url);
        };
        img.onerror = ()=>{ alert('图片加载失败，文件可能不是受支持的图片格式。'); URL.revokeObjectURL(url); };
        img.src = url;
      }

      function drawPreview() {
        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        if (!state.loaded) return;
        const iw = state.img.naturalWidth;
        const ih = state.img.naturalHeight;
        const cw = canvas.width, ch = canvas.height;
        const ang = (state.angle||0) * Math.PI/180;
        const rotW = (Math.abs(state.angle)%180===0) ? iw : ih;
        const rotH = (Math.abs(state.angle)%180===0) ? ih : iw;
        const scale = Math.min(cw/rotW, ch/rotH);
        state.draw.scale = scale;
        state.draw.centerX = cw/2;
        state.draw.centerY = ch/2;
        state.draw.angleRad = ang;
        state.draw.offsetX = 0; // 不再使用简单偏移，改用中心点
        state.draw.offsetY = 0;
        ctx.save();
        ctx.translate(state.draw.centerX, state.draw.centerY);
        ctx.rotate(ang);
        ctx.drawImage(state.img, -iw/2*scale, -ih/2*scale, iw*scale, ih*scale);
        ctx.restore();

        // 画裁切选区（预览层由CSS承载边框，这里用半透明填充）
        if (state.crop) {
          // 将裁剪矩形四个角旋转后绘制为多边形，以匹配预览旋转
          const ang = state.draw.angleRad;
          const s = state.draw.scale;
          const cx = state.draw.centerX;
          const cy = state.draw.centerY;
          // 原图坐标下四角（以图像中心为参考）
          const x0 = state.crop.x - iw/2;
          const y0 = state.crop.y - ih/2;
          const x1 = x0 + state.crop.w;
          const y1 = y0 + state.crop.h;
          const corners = [
            {x:x0, y:y0},
            {x:x1, y:y0},
            {x:x1, y:y1},
            {x:x0, y:y1}
          ].map(p=>{
            const xr = p.x * Math.cos(ang) - p.y * Math.sin(ang);
            const yr = p.x * Math.sin(ang) + p.y * Math.cos(ang);
            return { x: cx + xr*s, y: cy + yr*s };
          });
          // 记录画布上的裁剪框四角用于命中测试
          state.draw.cropCanvasCorners = corners;
          ctx.save();
          ctx.strokeStyle = '#3a7afe';
          ctx.setLineDash([6,4]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(corners[0].x, corners[0].y);
          for (let i=1;i<corners.length;i++) ctx.lineTo(corners[i].x, corners[i].y);
          ctx.closePath();
          ctx.stroke();
          ctx.fillStyle = 'rgba(58,122,254,0.15)';
          ctx.fill();
          ctx.restore();

          // 绘制四个角的调整手柄
          ctx.save();
          ctx.fillStyle = '#3a7afe';
          for (const c of corners) {
            ctx.beginPath();
            ctx.arc(c.x, c.y, 5, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }
      }

      // 事件：文件选择
      fileInput.addEventListener('change', (e)=>{
        const file = e.target.files && e.target.files[0];
        loadFile(file);
      });

      // 拖拽上传到预览区域
      ['dragenter','dragover'].forEach(evtName => {
        dropZone.addEventListener(evtName, (e)=>{
          e.preventDefault();
          e.stopPropagation();
          dropZone.classList.add('dragover');
          if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
        });
      });
      dropZone.addEventListener('dragleave', (e)=>{
        dropZone.classList.remove('dragover');
      });
      dropZone.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        const dt = e.dataTransfer;
        if (!dt) return;
        let file = dt.files && dt.files[0];
        if (!file && dt.items && dt.items.length) {
          for (const it of dt.items) {
            if (it.kind === 'file') { file = it.getAsFile(); break; }
          }
        }
        loadFile(file);
      });

      // 同步在 canvas 上也绑定拖拽事件，提升兼容性
      ['dragenter','dragover'].forEach(evtName => {
        canvas.addEventListener(evtName, (e)=>{
          e.preventDefault();
          e.stopPropagation();
          dropZone.classList.add('dragover');
          if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
        });
      });
      canvas.addEventListener('dragleave', (e)=>{
        dropZone.classList.remove('dragover');
      });
      canvas.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        const dt = e.dataTransfer;
        if (!dt) return;
        let file = dt.files && dt.files[0];
        if (!file && dt.items && dt.items.length) {
          for (const it of dt.items) {
            if (it.kind === 'file') { file = it.getAsFile(); break; }
          }
        }
        loadFile(file);
      });

      // 事件：旋转（按钮，每次90°）
      rotateLeftBtn.addEventListener('click', ()=>{
        state.angle = ((state.angle - 90) % 360 + 360) % 360;
        rotateVal.textContent = state.angle + '°';
        drawPreview();
        updateFinal();
      });
      rotateRightBtn.addEventListener('click', ()=>{
        state.angle = (state.angle + 90) % 360;
        rotateVal.textContent = state.angle + '°';
        drawPreview();
        updateFinal();
      });

      // 事件：清除裁切
      clearCropBtn.addEventListener('click', ()=>{
        state.crop = null;
        drawPreview();
        updateFinal();
      });

      // 裁切选择（鼠标/触控）
      let selecting = false; let startX=0, startY=0; let curX=0, curY=0;
      let draggingCrop = false; let resizingCropIdx = -1; let lastImgPos = null;
      function toCanvasPos(evt){
        const rect = canvas.getBoundingClientRect();
        const clientX = (evt.touches ? evt.touches[0].clientX : evt.clientX);
        const clientY = (evt.touches ? evt.touches[0].clientY : evt.clientY);
        const xCss = clientX - rect.left;
        const yCss = clientY - rect.top;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {x: xCss * scaleX, y: yCss * scaleY};
      }
      function toImagePos(cx, cy){
        // 将画布点转换为原图坐标（考虑旋转与缩放）
        const ang = state.draw.angleRad;
        const s = state.draw.scale;
        const cx0 = state.draw.centerX;
        const cy0 = state.draw.centerY;
        // 以画布中心为原点
        const dx = cx - cx0;
        const dy = cy - cy0;
        // 逆旋转
        const ixr = dx * Math.cos(-ang) - dy * Math.sin(-ang);
        const iyr = dx * Math.sin(-ang) + dy * Math.cos(-ang);
        // 去缩放并转换到原图左上角坐标系
        const ix = ixr / s + state.img.naturalWidth/2;
        const iy = iyr / s + state.img.naturalHeight/2;
        return { x: ix, y: iy };
      }
      function insideImage(cx, cy){
        const p = toImagePos(cx, cy);
        return p.x>=0 && p.y>=0 && p.x<=state.img.naturalWidth && p.y<=state.img.naturalHeight;
      }

      function hitTestHandle(cx, cy){
        const corners = state.draw.cropCanvasCorners || [];
        let idx = -1; let best = 1e9;
        for (let i=0;i<corners.length;i++){
          const dx = cx - corners[i].x; const dy = cy - corners[i].y;
          const d = Math.hypot(dx, dy);
          if (d < best) { best = d; idx = i; }
        }
        return best <= 12 ? idx : -1;
      }

      function pointInsideCrop(cx, cy){
        const p = toImagePos(cx, cy);
        if (!state.crop) return false;
        const x0 = state.crop.x, y0 = state.crop.y;
        const x1 = x0 + state.crop.w, y1 = y0 + state.crop.h;
        return p.x>=x0 && p.x<=x1 && p.y>=y0 && p.y<=y1;
      }

      function beginSelect(evt){
        if(!state.loaded) return;
        const pc = toCanvasPos(evt);
        // 有裁剪框时：优先命中角手柄或内部拖动
        if (state.crop) {
          const handle = hitTestHandle(pc.x, pc.y);
          if (handle >= 0) { resizingCropIdx = handle; lastImgPos = toImagePos(pc.x, pc.y); evt.preventDefault(); return; }
          if (pointInsideCrop(pc.x, pc.y)) { draggingCrop = true; lastImgPos = toImagePos(pc.x, pc.y); evt.preventDefault(); return; }
        }
        // 否则开始新的框选
        selecting = true; startX=pc.x; startY=pc.y; curX=pc.x; curY=pc.y; evt.preventDefault();
      }
      function moveSelect(evt){
        if(!state.loaded) return;
        const pc = toCanvasPos(evt);
        if (resizingCropIdx >= 0 && state.crop) {
          const imgP = toImagePos(pc.x, pc.y);
          const iw = state.img.naturalWidth, ih = state.img.naturalHeight;
          const c = state.crop;
          const cornersImg = [
            {x:c.x, y:c.y},
            {x:c.x + c.w, y:c.y},
            {x:c.x + c.w, y:c.y + c.h},
            {x:c.x, y:c.y + c.h}
          ];
          const oppIndex = [2,3,0,1][resizingCropIdx];
          const opp = cornersImg[oppIndex];
          const rx = clamp(Math.min(imgP.x, opp.x), 0, iw);
          const ry = clamp(Math.min(imgP.y, opp.y), 0, ih);
          const rw = clamp(Math.abs(imgP.x - opp.x), 1, iw - rx);
          const rh = clamp(Math.abs(imgP.y - opp.y), 1, ih - ry);
          state.crop = { x: rx, y: ry, w: rw, h: rh };
          drawPreview(); evt.preventDefault(); return;
        }
        if (draggingCrop && state.crop) {
          const imgP = toImagePos(pc.x, pc.y);
          const dx = imgP.x - lastImgPos.x; const dy = imgP.y - lastImgPos.y; lastImgPos = imgP;
          const iw = state.img.naturalWidth, ih = state.img.naturalHeight;
          const nx = clamp(state.crop.x + dx, 0, iw - state.crop.w);
          const ny = clamp(state.crop.y + dy, 0, ih - state.crop.h);
          state.crop.x = nx; state.crop.y = ny;
          drawPreview(); evt.preventDefault(); return;
        }
        if (!selecting) return;
        curX=pc.x; curY=pc.y; drawPreview(); const x=Math.min(startX,curX), y=Math.min(startY,curY), w=Math.abs(curX-startX), h=Math.abs(curY-startY); ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle='#3a7afe'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); ctx.fillStyle='rgba(58,122,254,0.12)'; ctx.fillRect(x,y,w,h); ctx.restore(); evt.preventDefault();
      }
      function endSelect(evt){
        if(!state.loaded) return;
        if (resizingCropIdx >= 0 || draggingCrop) { resizingCropIdx = -1; draggingCrop = false; updateFinal(); evt.preventDefault(); return; }
        if (!selecting) return;
        selecting=false; const x=Math.min(startX,curX), y=Math.min(startY,curY), w=Math.abs(curX-startX), h=Math.abs(curY-startY); // 转为图像坐标
        const p1 = toImagePos(x,y); const p2 = toImagePos(x+w, y+h);
        const rx = clamp(Math.min(p1.x,p2.x),0,state.img.naturalWidth);
        const ry = clamp(Math.min(p1.y,p2.y),0,state.img.naturalHeight);
        const rw = clamp(Math.abs(p2.x-p1.x),0,state.img.naturalWidth-rx);
        const rh = clamp(Math.abs(p2.y-p1.y),0,state.img.naturalHeight-ry);
        if (rw>10 && rh>10 && insideImage(x,y) && insideImage(x+w,y+h)) {
          state.crop = { x: rx, y: ry, w: rw, h: rh };
        }
        drawPreview(); updateFinal(); evt.preventDefault(); }

      canvas.addEventListener('mousedown', beginSelect);
      canvas.addEventListener('mousemove', moveSelect);
      window.addEventListener('mouseup', endSelect);
      canvas.addEventListener('touchstart', beginSelect, {passive:false});
      canvas.addEventListener('touchmove', moveSelect, {passive:false});
      canvas.addEventListener('touchend', endSelect);

      // 初始绘制空白
      drawPreview();
      if (overlay) overlay.classList.toggle('hidden', !!state.loaded);

      return { state, drawPreview };
    }

    // 创建两个编辑器
    const ed1 = createEditor({ fileId:'file1', canvasId:'canvas1', overlayId:'overlay1', rotateValId:'rotVal1', rotateLeftId:'rotateLeft1', rotateRightId:'rotateRight1', clearCropId:'clearCrop1' });
    const ed2 = createEditor({ fileId:'file2', canvasId:'canvas2', overlayId:'overlay2', rotateValId:'rotVal2', rotateLeftId:'rotateLeft2', rotateRightId:'rotateRight2', clearCropId:'clearCrop2' });

    const finalCanvas = document.getElementById('finalCanvas');
    const fctx = finalCanvas.getContext('2d');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusMsg = document.getElementById('statusMsg');
    const sizeLine = document.getElementById('sizeLine');
    const filenameInput = document.getElementById('filename');

    function processImage(editor) {
      if (!editor.state.loaded) return null;
      const img = editor.state.img;
      const angle = (editor.state.angle || 0) * Math.PI/180;
      const crop = editor.state.crop || { x:0, y:0, w: img.naturalWidth, h: img.naturalHeight };

      // 1) 先裁切
      const cut = document.createElement('canvas');
      cut.width = Math.max(1, Math.round(crop.w));
      cut.height = Math.max(1, Math.round(crop.h));
      const cctx = cut.getContext('2d');
      cctx.imageSmoothingQuality = 'high';
      cctx.drawImage(img, -crop.x, -crop.y);

      // 2) 再旋转，生成紧致边界
      if (Math.abs(angle) > 1e-3) {
        const w = cut.width, h = cut.height;
        const cos = Math.abs(Math.cos(angle)), sin = Math.abs(Math.sin(angle));
        const rw = Math.max(1, Math.floor(w*cos + h*sin));
        const rh = Math.max(1, Math.floor(w*sin + h*cos));
        const rot = document.createElement('canvas');
        rot.width = rw; rot.height = rh;
        const rctx = rot.getContext('2d');
        rctx.imageSmoothingQuality = 'high';
        rctx.translate(rw/2, rh/2);
        rctx.rotate(angle);
        rctx.drawImage(cut, -w/2, -h/2);
        return rot;
      }
      return cut;
    }

    function composeA4AndEstimate() {
      const items = [];
      const p1 = ed1.state.loaded ? processImage(ed1) : null;
      const p2 = ed2.state.loaded ? processImage(ed2) : null;
      if (p1) items.push(p1);
      if (p2) items.push(p2);

      if (items.length === 0) {
        finalCanvas.width = 600; finalCanvas.height = 400;
        fctx.fillStyle = '#ffffff';
        fctx.fillRect(0,0,finalCanvas.width, finalCanvas.height);
        downloadBtn.disabled = true;
        statusMsg.textContent = '请上传图片后预览拼接效果。';
        sizeLine.textContent = '当前估算大小：--';
        syncRightHeight();
        return null;
      }

      const marginLR = MARGIN_LR;
      const marginTB = MARGIN_TB;
      const gapVB = GAP_VB;

      // 以图片一的最大边为基准统一尺寸（避免大小不一致）
      const refMax = p1 ? Math.max(p1.width, p1.height) : Math.max(items[0].width, items[0].height);
      const scaled = items.map(it => {
        const s = refMax / Math.max(it.width, it.height);
        return {
          w: Math.max(1, Math.round(it.width * s)),
          h: Math.max(1, Math.round(it.height * s)),
          s,
          src: it
        };
      });

      // 计算画布尺寸（左右居中对齐、上下间距）
      const width = Math.max(...scaled.map(it => it.w)) + marginLR*2;
      let height = marginTB * 2;
      for (let i=0;i<scaled.length;i++) height += scaled[i].h;
      height += gapVB * Math.max(0, scaled.length - 1);

      finalCanvas.width = Math.max(1, Math.floor(width));
      finalCanvas.height = Math.max(1, Math.floor(height));
      fctx.fillStyle = '#ffffff';
      fctx.fillRect(0,0,finalCanvas.width, finalCanvas.height);

      let y = marginTB;
      for (let i=0;i<scaled.length;i++) {
        const it = scaled[i];
        const x = Math.floor((finalCanvas.width - it.w)/2);
        fctx.drawImage(it.src, x, y, it.w, it.h);
        y += it.h + (i < scaled.length-1 ? gapVB : 0);
      }

      // 估算大小（以质量0.9预估）
      const previewUrl = finalCanvas.toDataURL('image/jpeg', 0.9);
      const bytes = dataUrlSizeBytes(previewUrl);
      sizeLine.textContent = `当前估算大小（q=0.9）：${(bytes/1024).toFixed(1)}KB`;
      downloadBtn.disabled = false;
      statusMsg.textContent = `预览已更新（已加载${items.length}张），可点击下载按钮导出（自动≤500KB）。`;
      syncRightHeight();
      return { previewUrl, bytes };
    }

    function updateFinal(){ composeA4AndEstimate(); }

    // 下载逻辑：限制≤500KB，优先降低质量，其次缩小画布
    downloadBtn.addEventListener('click', ()=>{
      composeA4AndEstimate();
      let quality = 0.92;
      let url = finalCanvas.toDataURL('image/jpeg', quality);
      let bytes = dataUrlSizeBytes(url);
      let attempts = 0;
      while (bytes > MAX_BYTES && quality > 0.40 && attempts < 10) {
        quality -= 0.08; attempts++;
        url = finalCanvas.toDataURL('image/jpeg', quality);
        bytes = dataUrlSizeBytes(url);
      }
      // 若质量降低仍超限，则缩放画布
      let shrinkSteps = 0;
      while (bytes > MAX_BYTES && shrinkSteps < 8) {
        const scale = 0.88; // 逐步缩小
        const sw = Math.max(200, Math.floor(finalCanvas.width * scale));
        const sh = Math.max(200, Math.floor(finalCanvas.height * scale));
        const tmp = document.createElement('canvas');
        tmp.width = sw; tmp.height = sh;
        const tctx = tmp.getContext('2d');
        tctx.imageSmoothingQuality = 'high';
        tctx.drawImage(finalCanvas, 0, 0, sw, sh);
        finalCanvas.width = sw; finalCanvas.height = sh;
        fctx.drawImage(tmp, 0, 0);
        url = finalCanvas.toDataURL('image/jpeg', quality);
        bytes = dataUrlSizeBytes(url);
        shrinkSteps++;
      }

      if (bytes > MAX_BYTES) {
        alert('在保持合理清晰度下仍无法压缩到500KB以内，请尝试减小裁切范围或使用更低分辨率图片。');
        return;
      }

      const name = (filenameInput.value || '拼接图').replace(/[\\/:*?"<>|]/g,'').trim() || '拼接图';
      const a = document.createElement('a');
      a.href = url;
      a.download = name + '.jpg';
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    // 初次渲染
    updateFinal();
    // 全局拦截与提示层控制
    const pageDragOverlay = document.getElementById('pageDragOverlay');
    let pageDragCount = 0;
    function showPageOverlay(){ if (pageDragOverlay) pageDragOverlay.classList.remove('hidden'); }
    function hidePageOverlay(){ if (pageDragOverlay) pageDragOverlay.classList.add('hidden'); }

    window.addEventListener('dragenter', (e)=>{
      pageDragCount++;
      showPageOverlay();
      e.preventDefault();
    }, false);
    window.addEventListener('dragover', (e)=>{
      showPageOverlay();
      if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
      e.preventDefault();
    }, false);
    window.addEventListener('dragleave', (e)=>{
      pageDragCount = Math.max(0, pageDragCount - 1);
      if (pageDragCount === 0) hidePageOverlay();
      e.preventDefault();
    }, false);
    window.addEventListener('drop', (e)=>{
      hidePageOverlay();
      pageDragCount = 0;
      e.preventDefault(); // 防止页面直接打开文件
    }, false);
    window.addEventListener('dragend', ()=>{ hidePageOverlay(); pageDragCount = 0; }, false);
  </script>
  </body>
  </html>
<!-- END: 图片拼接工具.html -->
    </template>

    <template id="tpl-compress">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Standalone Image Compressor</title>
    <style>
      :root { --bg: #f7fafc; --fg: #1f2937; --muted: #6b7280; --primary: #111827; --border: #e5e7eb; }
      * { box-sizing: border-box; }
      body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; color: var(--fg); background: var(--bg); }
      .container { max-width: 1600px; margin: 0 auto; padding: 24px; }
      .card { background: #fff; border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
      .toolbar { display:flex; gap:12px; align-items:center; justify-content:space-between; padding: 12px; border-bottom:1px solid var(--border); }
      .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
      .list { padding: 12px; }
      .item { display:flex; align-items:center; justify-content:space-between; padding:12px 0; border-bottom:1px solid var(--border); }
      .thumb { width:48px; height:48px; border-radius:6px; overflow:hidden; margin-right:12px; flex-shrink:0; }
      .thumb img { width:100%; height:100%; object-fit:cover; }
      .meta { display:flex; align-items:center; max-width:60%; }
      .name { font-weight:600; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
      .row { display:flex; gap:8px; color:var(--muted); font-size:12px; }
      .right { display:flex; align-items:center; gap:8px; }
      .button { padding:8px 12px; border:1px solid var(--border); border-radius:6px; background:#fff; cursor:pointer; }
      .button.primary { background: var(--primary); color:#fff; border-color: var(--primary); }
      .button.danger { background:#ef4444; color:#fff; border-color:#ef4444; }
      .button:disabled { opacity:.6; cursor:not-allowed; }
      .tag { font-size:12px; padding:0 6px; height:20px; line-height:20px; border-radius:10px; border:1px solid var(--border); color:var(--muted); }
      .small { font-size:12px; }
      .title { text-align:center; font-size:28px; font-weight:800; margin: 16px 0 6px; }
      .subtitle { text-align:center; color:var(--muted); font-size:14px; margin-bottom: 16px; }
      input[type="range"] { width: 160px; }
      .hidden { display:none; }
      .drop-area { border:2px dashed var(--border); background:#fff; border-radius:8px; padding:24px; text-align:center; color:var(--muted); margin:12px; cursor:pointer; transition: all .12s ease-in-out; }
      .drop-area.highlight { border-color:#60a5fa; background:#f0f9ff; color:#1d4ed8; }
      .drop-area:hover { border-color:#60a5fa; background:#f0f9ff; color:#1d4ed8; }
      .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:9999; }
      .modal { background:#fff; border-radius:8px; border:1px solid var(--border); width: min(1200px, 96vw); max-height: 90vh; overflow: auto; }
      .modal-header { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--border); }
      .modal-body { padding:16px; }
      .compare-box { position:relative; width:100%; aspect-ratio: 16/9; background:#f9fafb; border:1px solid var(--border); border-radius:8px; overflow:hidden; }
      .compare-box img { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; }
      .compare-top { position:absolute; inset:0; clip-path: polygon(0 0, var(--cmp, 50%) 0, var(--cmp, 50%) 100%, 0 100%); }
      #compareBottomImg { z-index:1; }
      #compareTopWrap { z-index:2; }
      #compareHandle { z-index:3; }
      .compare-label { z-index:0; }
      @media (max-width: 640px) {
        .container { padding: 12px; }
        .title { font-size:22px; }
        .subtitle { font-size:12px; }
        .card { border-radius:10px; }
        .toolbar { flex-direction: column; align-items: stretch; gap:10px; }
        .controls { flex-wrap: wrap; }
        .button { padding:10px 12px; font-size:14px; }
        input[type="range"] { width: 100%; }
        .drop-area { margin: 8px; padding: 20px; font-size: 13px; }
        .item { flex-direction: column; align-items: flex-start; gap: 8px; }
        .thumb { width: 40px; height: 40px; }
        .meta { max-width: 100%; }
        .right { width: 100%; justify-content: flex-end; }
        .compare-box { height: 60vh; aspect-ratio: auto; }
        .compare-handle { width: 36px; margin-left: -18px; }
        .slider-icon { width: 44px; height: 44px; }
        .slider-line { width: 3px; }
      }
      .compare-controls { display:flex; align-items:center; gap:8px; padding:12px 0; }
      .hidden { display:none; }
      .compare-handle { position:absolute; top:0; bottom:0; width:24px; margin-left:-12px; cursor:ew-resize; display:block; z-index:3; }
      .slider-line { position:absolute; top:0; bottom:0; left:50%; transform:translateX(-50%); width:2px; background:#60a5fa; }
      .slider-icon { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); display:flex; align-items:center; justify-content:center; gap:6px; width:36px; height:36px; border-radius:50%; background:#fff; color:#1f2937; border:1px solid #e5e7eb; box-shadow:0 2px 8px rgba(0,0,0,.15); }
      .compare-label { position:absolute; top:8px; padding:4px 8px; font-size:12px; border-radius:999px; background:#111827; color:#fff; opacity:.8; pointer-events:none; }
      .label-left { left:8px; }
      .label-right { right:8px; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="title">图片压缩</h1>
      <p class="subtitle">添加图片，选择格式与质量，生成压缩结果并下载。可以批量压缩图片。</p>
      <div class="card">
        <div class="toolbar">
          <div class="controls">
            <label class="button" for="fileInput">添加图片</label>
            <input id="fileInput" type="file" accept="image/*" multiple class="hidden" />
            <button id="clearBtn" class="button">清空</button>
            <span class="small">压缩格式</span>
            <select id="formatSelect" class="button">
              <option value="auto">auto</option>
              <option value="jpeg" selected>jpeg</option>
              <option value="webp">webp</option>
            </select>
            <span class="small">质量</span>
            <input id="qualityRange" type="range" min="10" max="95" value="50" />
            <span id="qualityText" class="small">50</span>
            <button id="recompressBtn" class="button">重新压缩</button>
            <button id="downloadAllBtn" class="button primary">下载全部</button>
          </div>
          <div id="progressHint" class="small" style="color:var(--muted)"></div>
        </div>
        <div id="dropArea" class="drop-area">
          点击或拖动图片到这个区域，或按 Ctrl+V 粘贴到这里
        </div>
      <div id="list" class="list"></div>
      </div>
    </div>

    <div id="compareBackdrop" class="modal-backdrop hidden">
      <div class="modal">
        <div class="modal-header">
          <div id="compareTitle" class="small" style="font-size:14px; font-weight:600"></div>
          <div>
            <button id="compareCloseBtn" class="button">关闭</button>
          </div>
        </div>
        <div class="modal-body">
          <div id="compareBox" class="compare-box">
            <img id="compareBottomImg" alt="原图" />
            <div id="compareTopWrap" class="compare-top" style="--cmp:50%">
              <img id="compareTopImg" alt="压缩后" />
            </div>
            <div id="compareHandle" class="compare-handle" style="left:50%">
              <div class="slider-line"></div>
              <div class="slider-icon">
                <span role="img" aria-label="left" class="anticon anticon-left">
                  <svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true">
                    <path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path>
                  </svg>
                </span>
                <span role="img" aria-label="right" class="anticon anticon-right">
                  <svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true">
                    <path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path>
                  </svg>
                </span>
              </div>
            </div>
            <div class="compare-label label-left">压缩后</div>
            <div class="compare-label label-right">原始</div>
          </div>
          <div class="compare-controls"><span class="small">滑动对比</span><span id="comparePercent" class="small">50%</span></div>
        </div>
      </div>
    </div>

    <script>
      const state = {
        items: [],
        option: {
          format: { target: undefined, transparentFill: '#FFFFFF' },
          jpeg: { quality: 0.7 },
        },
      };

      const formatSelect = document.getElementById('formatSelect');
      const qualityRange = document.getElementById('qualityRange');
      const qualityText = document.getElementById('qualityText');
      const fileInput = document.getElementById('fileInput');
      const listEl = document.getElementById('list');
      const progressHintEl = document.getElementById('progressHint');
      const dropArea = document.getElementById('dropArea');
      const downloadAllBtn = document.getElementById('downloadAllBtn');
      const compareBackdrop = document.getElementById('compareBackdrop');
      const compareTitle = document.getElementById('compareTitle');
      const compareCloseBtn = document.getElementById('compareCloseBtn');
      const compareBottomImg = document.getElementById('compareBottomImg');
      const compareTopImg = document.getElementById('compareTopImg');
      const compareTopWrap = document.getElementById('compareTopWrap');
      const compareBox = document.getElementById('compareBox');
      const compareHandle = document.getElementById('compareHandle');
      const comparePercent = document.getElementById('comparePercent');
      let compareItemKey = null;

      const Mimes = { jpg: 'image/jpeg', jpeg: 'image/jpeg', webp: 'image/webp', png: 'image/png' };

      function formatSize(bytes) {
        const units = ['B','KB','MB','GB'];
        let i = 0; let n = bytes;
        while (n >= 1024 && i < units.length - 1) { n /= 1024; i++; }
        return n.toFixed(n < 10 && i > 0 ? 2 : 0) + ' ' + units[i];
      }

      function getOutputFileName(item) {
        const name = item.name.replace(/\.[^.]+$/, '');
        const target = state.option.format.target;
        let ext = target ? target : item.blob.type.split('/')[1];
        if (ext === 'jpeg') ext = 'jpg';
        return name + '-已压缩.' + ext;
      }

      function updateProgressHint() {
        const total = state.items.length;
        let done = 0, origin = 0, out = 0;
        state.items.forEach(i => { origin += i.blob.size; if (i.compress) { done++; out += i.compress.blob.size; } });
        const percent = total ? Math.ceil(done * 100 / total) : 0;
        const rate = origin ? Math.abs(((out - origin) * 100) / origin).toFixed(2) : '0.00';
        progressHintEl.textContent = `完成: ${done}/${total} (${percent}%), 体积变化: ${rate}%`;
      }

      function renderList() {
        listEl.innerHTML = '';
        state.items.slice().reverse().forEach(info => {
          const row = document.createElement('div'); row.className = 'item';
          const left = document.createElement('div'); left.className = 'meta';
          const thumb = document.createElement('div'); thumb.className = 'thumb';
          const img = document.createElement('img'); img.src = info.previewSrc || info.src; thumb.appendChild(img);
          const text = document.createElement('div'); text.style.flex = '1';
          const name = document.createElement('div'); name.className = 'name'; name.textContent = info.name; text.appendChild(name);
          const tags = document.createElement('div'); tags.className = 'row';
          const typeTag = document.createElement('span'); typeTag.className = 'tag'; typeTag.textContent = (info.blob.type.split('/')[1] || '').toUpperCase(); tags.appendChild(typeTag);
          const wh = document.createElement('span'); wh.textContent = info.width && info.height ? `${info.width}*${info.height}` : '-'; tags.appendChild(wh);
          const size = document.createElement('span'); size.textContent = formatSize(info.blob.size); tags.appendChild(size);
          text.appendChild(tags);
          left.appendChild(thumb); left.appendChild(text);

          const right = document.createElement('div'); right.className = 'right';
          if (info.compress) {
            const delta = (((info.compress.blob.size - info.blob.size) / info.blob.size) * 100).toFixed(2);
            const deltaEl = document.createElement('div'); deltaEl.style.textAlign = 'right';
            const d1 = document.createElement('div'); d1.style.fontWeight = '700'; d1.style.fontSize = '13px'; d1.textContent = `${delta}%`;
            d1.style.color = (info.blob.size > info.compress.blob.size) ? '#16a34a' : '#dc2626';
            const d2 = document.createElement('div'); d2.className = 'small'; d2.style.color = d1.style.color; d2.textContent = formatSize(info.compress.blob.size);
            deltaEl.appendChild(d1); deltaEl.appendChild(d2);
          const dlBtn = document.createElement('button'); dlBtn.className = 'button primary'; dlBtn.title = '下载压缩结果'; dlBtn.textContent = '下载';
          dlBtn.addEventListener('click', () => {
            const a = document.createElement('a'); a.href = info.compress.src; a.download = getOutputFileName(info); document.body.appendChild(a); a.click(); a.remove();
          });
          right.appendChild(deltaEl); right.appendChild(dlBtn);
            const cmpBtn = document.createElement('button'); cmpBtn.className = 'button'; cmpBtn.title = '对比前后效果'; cmpBtn.textContent = '对比';
            cmpBtn.addEventListener('click', () => openCompare(info));
            right.appendChild(cmpBtn);
          const delBtn = document.createElement('button'); delBtn.className = 'button danger'; delBtn.title = '删除该图片'; delBtn.textContent = '删除';
          delBtn.addEventListener('click', () => removeItem(info.key));
          right.appendChild(delBtn);
          } else {
            const sp = document.createElement('span'); sp.className = 'small'; sp.textContent = '处理中...'; right.appendChild(sp);
          }

          row.appendChild(left); row.appendChild(right);
          listEl.appendChild(row);
        });
        updateProgressHint();
        const downloadable = state.items.some(i => !!i.compress);
        downloadAllBtn.disabled = !downloadable;
      }

      async function getImageDimension(blob) {
        const url = URL.createObjectURL(blob);
        try {
          const img = new Image(); img.crossOrigin = 'Anonymous';
          const size = await new Promise((resolve, reject) => {
            img.onload = () => resolve({ width: img.width, height: img.height });
            img.onerror = reject; img.src = url;
          });
          return size;
        } finally { URL.revokeObjectURL(url); }
      }

      async function compressItem(info) {
        const target = state.option.format.target;
        const isJpeg = target === 'jpeg';
        const type = target ? Mimes[target] : info.blob.type;
        const bmp = await createImageBitmap(info.blob);
        const canvas = document.createElement('canvas'); canvas.width = bmp.width; canvas.height = bmp.height;
        const ctx = canvas.getContext('2d');
        if (isJpeg) { ctx.fillStyle = state.option.format.transparentFill; ctx.fillRect(0,0,canvas.width,canvas.height); }
        ctx.drawImage(bmp, 0, 0);
        bmp.close();
        const blob = await new Promise(resolve => canvas.toBlob(resolve, type, state.option.jpeg.quality));
        const src = URL.createObjectURL(blob);
        info.width = canvas.width; info.height = canvas.height;
        info.compress = { width: canvas.width, height: canvas.height, blob, src };
      }

      function openCompare(info) {
        compareItemKey = info.key;
        compareTitle.textContent = `${info.name}（原始 ${formatSize(info.blob.size)} → 压缩后 ${formatSize(info.compress.blob.size)}）`;
        compareBottomImg.src = info.src;
        compareTopImg.src = info.compress.src;
        setComparePercent(50);
        compareBackdrop.classList.remove('hidden');
      }
      function closeCompare() {
        compareItemKey = null;
        compareBackdrop.classList.add('hidden');
      }
      compareCloseBtn.addEventListener('click', closeCompare);
      compareBackdrop.addEventListener('click', (e) => { if (e.target === compareBackdrop) closeCompare(); });
      function setComparePercent(v) {
        let val = Math.max(0, Math.min(100, Math.round(v)));
        comparePercent.textContent = val + '%';
        compareTopWrap.style.setProperty('--cmp', val + '%');
        compareHandle.style.left = val + '%';
      }
      function updateFromClientX(x) {
        const rect = compareBox.getBoundingClientRect();
        const val = ((x - rect.left) / rect.width) * 100;
        setComparePercent(val);
      }
      let dragging = false;
      compareHandle.addEventListener('mousedown', (e) => { dragging = true; e.preventDefault(); });
      document.addEventListener('mousemove', (e) => { if (dragging) updateFromClientX(e.clientX); });
      document.addEventListener('mouseup', () => { dragging = false; });
      compareHandle.addEventListener('touchstart', (e) => { dragging = true; });
      document.addEventListener('touchmove', (e) => { if (dragging) { const t = e.touches[0]; updateFromClientX(t.clientX); } });
      document.addEventListener('touchend', () => { dragging = false; });
      compareBox.addEventListener('click', (e) => { updateFromClientX(e.clientX); });

      async function addFiles(files) {
        for (const file of files) {
          if (!file.type.startsWith('image/')) continue;
          const src = URL.createObjectURL(file);
          const info = { key: Date.now()+Math.random(), name: file.name, blob: file, width: 0, height: 0, src };
          const { width, height } = await getImageDimension(file);
          info.width = width; info.height = height;
          state.items.push(info);
          info.previewSrc = info.src;
          compressItem(info).then(() => { renderList(); }).catch(() => { renderList(); });
        }
        renderList();
      }

      function setQuality(value) {
        const percent = value / 100; state.option.jpeg.quality = percent; qualityText.textContent = String(value);
      }

      function setFormat(value) {
        if (value !== 'auto') state.option.format.target = value; else state.option.format.target = undefined;
      }

      async function recompressAll() {
        for (const info of state.items) {
          if (info.compress?.src) { URL.revokeObjectURL(info.compress.src); }
          info.compress = undefined;
          await compressItem(info);
        }
        renderList();
      }

      document.getElementById('clearBtn').addEventListener('click', () => {
        state.items.forEach(i => { if (i.src) URL.revokeObjectURL(i.src); if (i.compress?.src) URL.revokeObjectURL(i.compress.src); });
        state.items = []; renderList();
      });
      document.getElementById('recompressBtn').addEventListener('click', recompressAll);
      let recompressTimer = null;
      function scheduleRecompress(delay = 300) {
        if (recompressTimer) clearTimeout(recompressTimer);
        recompressTimer = setTimeout(() => { recompressAll(); }, delay);
      }
      qualityRange.addEventListener('input', e => { setQuality(Number(e.target.value)); scheduleRecompress(250); });
      formatSelect.addEventListener('change', e => setFormat(e.target.value));
      fileInput.addEventListener('change', e => addFiles(Array.from(e.target.files || [])));

      dropArea.addEventListener('click', () => fileInput.click());
      dropArea.addEventListener('dragover', e => { e.preventDefault(); dropArea.classList.add('highlight'); });
      dropArea.addEventListener('dragleave', () => dropArea.classList.remove('highlight'));
      dropArea.addEventListener('drop', e => {
        e.preventDefault(); dropArea.classList.remove('highlight');
        const files = Array.from(e.dataTransfer?.files || []);
        addFiles(files);
      });
      document.addEventListener('paste', e => {
        const items = Array.from(e.clipboardData?.items || []);
        const files = [];
        items.forEach(it => { if (it.kind === 'file') { const f = it.getAsFile(); if (f && f.type.startsWith('image/')) files.push(f); } });
        if (files.length) addFiles(files);
      });

      function toDosTime(date) {
        const d = date || new Date();
        const dosTime = (d.getHours() << 11) | (d.getMinutes() << 5) | (Math.floor(d.getSeconds() / 2));
        const dosDate = (((d.getFullYear() - 1980) & 0x7f) << 9) | ((d.getMonth() + 1) << 5) | d.getDate();
        return { dosTime, dosDate };
      }
      function crc32(buf) {
        let c = ~0; const table = crc32.table || (crc32.table = (function(){
          let t = new Uint32Array(256);
          for (let i=0; i<256; i++) { let r=i; for (let j=0; j<8; j++) r = (r & 1) ? (0xEDB88320 ^ (r >>> 1)) : (r >>> 1); t[i]=r; }
          return t;
        })());
        for (let i=0; i<buf.length; i++) c = table[(c ^ buf[i]) & 0xFF] ^ (c >>> 8);
        return (~c) >>> 0;
      }
      function u16(n) { const a = new Uint8Array(2); a[0] = n & 0xFF; a[1] = (n >>> 8) & 0xFF; return a; }
      function u32(n) { const a = new Uint8Array(4); a[0] = n & 0xFF; a[1] = (n >>> 8) & 0xFF; a[2] = (n >>> 16) & 0xFF; a[3] = (n >>> 24) & 0xFF; return a; }
      function concat(arrays) {
        let len = 0; arrays.forEach(a => len += a.length);
        const out = new Uint8Array(len); let off = 0;
        arrays.forEach(a => { out.set(a, off); off += a.length; });
        return out;
      }
      async function toZipBlob() {
        const locals = []; const centrals = [];
        let offset = 0; const now = new Date(); const { dosTime, dosDate } = toDosTime(now);
        const entries = [];
        for (const info of state.items) {
          if (!info.compress?.blob) continue;
          const name = getOutputFileName(info);
          const nameBytes = new TextEncoder().encode(name);
          const data = new Uint8Array(await info.compress.blob.arrayBuffer());
          const crc = crc32(data);
          const localHeader = concat([
            u32(0x04034b50),
            u16(20),
            u16(0),
            u16(0),
            u16(dosTime), u16(dosDate),
            u32(crc), u32(data.length), u32(data.length),
            u16(nameBytes.length), u16(0),
            nameBytes,
          ]);
          locals.push(localHeader, data);
          const localSize = localHeader.length + data.length;
          const entry = { nameBytes, crc, size: data.length, offset, dosTime, dosDate };
          entries.push(entry);
          offset += localSize;
        }
        let centralSize = 0;
        for (const e of entries) {
          const centralHeader = concat([
            u32(0x02014b50),
            u16(20), u16(20),
            u16(0), u16(0),
            u16(e.dosTime), u16(e.dosDate),
            u32(e.crc), u32(e.size), u32(e.size),
            u16(e.nameBytes.length), u16(0), u16(0),
            u16(0), u16(0),
            u32(0),
            u32(e.offset),
            e.nameBytes,
          ]);
          centrals.push(centralHeader);
          centralSize += centralHeader.length;
        }
        const centralStart = offset;
        const end = concat([
          u32(0x06054b50),
          u16(0), u16(0),
          u16(entries.length), u16(entries.length),
          u32(centralSize), u32(centralStart),
          u16(0),
        ]);
        const all = concat([...locals, ...centrals, end]);
        return new Blob([all], { type: 'application/zip' });
      }
      downloadAllBtn.addEventListener('click', async () => {
        downloadAllBtn.disabled = true;
        try {
          const blob = await toZipBlob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = '批量下载-已压缩.zip'; document.body.appendChild(a); a.click(); a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        } finally {
          renderList();
        }
      });

      function removeItem(key) {
        const idx = state.items.findIndex(i => i.key === key);
        if (idx >= 0) {
          const item = state.items[idx];
          if (item.src) URL.revokeObjectURL(item.src);
          if (item.compress?.src) URL.revokeObjectURL(item.compress.src);
          state.items.splice(idx, 1);
          renderList();
        }
      }

      setQuality(Number(qualityRange.value)); setFormat(formatSelect.value);
      renderList();
    </script>
  </body>
</html>
    </template>

    <!-- 内嵌模板：手写签名PNG -->
    <template id="tpl-sign"><!-- BEGIN: 手写签名png.html -->
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>手写签名保存为透明PNG</title>
    <style>
      :root {
        /* 强制使用浅色配色，避免深色模式下背景变黑 */
        color-scheme: light;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Microsoft YaHei", sans-serif;
        /* 固定为白底深色文案，保证黑色笔迹清晰可见 */
        background: #ffffff;
        color: #111111;
      }
      .container {
        max-width: 1600px;
        margin: 0 auto;
        padding: 40px;
      }
      h1 {
        font-size: 20px;
        margin: 0 0 12px 0;
      }
      .controls {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 12px;
      }
      .controls > * { font-size: 14px; }
      .controls label { display: inline-flex; align-items: center; gap: 6px; }
      .btn {
        padding: 6px 12px;
        border: 1px solid #8884;
        border-radius: 6px;
        background: #eee; 
        color: #222;
        cursor: pointer;
      }
      .btn:active { transform: translateY(1px); }
      .canvas-wrap {
        border: 1px dashed #8888;
        border-radius: 8px;
        background: transparent; /* 保持透明底 */
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 60vh; /* 自适应高度 */
        touch-action: none; /* 禁止手势滚动，便于触控绘制 */
        background: transparent; /* 透明背景 */
      }
      .tips {
        margin-top: 8px;
        font-size: 12px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>手写签名（导出透明PNG，仅包含笔迹）</h1>

      <div class="controls">
        <label>颜色 <input type="color" id="color" value="#000000" /></label>
        <label>粗细 <input type="range" id="size" min="1" max="20" value="4" /></label>
        <label>导出倍率 <input type="number" id="exportScale" min="1" max="6" step="1" value="2" style="width:64px" /></label>
        <button class="btn" id="clearBtn">清空</button>
        <button class="btn" id="undoBtn">撤销</button>
        <button class="btn" id="copyBtn">复制（电脑端）</button>
        <button class="btn" id="shareBtn">分享（手机端）</button>
        <button class="btn" id="saveFullBtn">保存PNG（原画布）</button>
        <button class="btn" id="saveTrimBtn">保存PNG（裁剪到笔迹）</button>
      </div>

      <div class="canvas-wrap">
        <canvas id="sigCanvas"></canvas>
      </div>

      <div class="tips">
        - 鼠标或触控直接在画布书写。<br />
        - 透明底：未填充背景，导出PNG仅含您写下的内容。<br />
        - 裁剪保存会自动去除四周多余的透明空白。<br />
        - 支持Ctrl+Z撤销上一步操作。<br />
        - 手机端复制图片请点击分享按钮。
      </div>
    </div>

    <script>
      const canvas = document.getElementById('sigCanvas');
      const ctx = canvas.getContext('2d', { alpha: true });
      const colorEl = document.getElementById('color');
      const sizeEl = document.getElementById('size');
      const exportScaleEl = document.getElementById('exportScale');
      const clearBtn = document.getElementById('clearBtn');
      const undoBtn = document.getElementById('undoBtn');
      const saveFullBtn = document.getElementById('saveFullBtn');
      const saveTrimBtn = document.getElementById('saveTrimBtn');
      const copyBtn = document.getElementById('copyBtn');
      const shareBtn = document.getElementById('shareBtn');

      let drawing = false;
      const strokes = []; // 每次落笔为一个笔划
      let currentStroke = null; // 正在书写的笔划

      function resizeCanvas() {
        const ratio = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        // 将逻辑像素提升到设备像素，保证清晰
        canvas.width = Math.max(1, Math.floor(rect.width * ratio));
        canvas.height = Math.max(1, Math.floor(rect.height * ratio));
        ctx.setTransform(1, 0, 0, 1, 0, 0); // 重置任何缩放
        ctx.scale(ratio, ratio); // 用CSS像素绘制（事件坐标基于CSS像素）
        // 绘图风格
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        redrawAll(); // 尺寸变化时重绘历史笔划
      }

      // 初始与窗口变化时调整
      const ro = new ResizeObserver(() => resizeCanvas());
      ro.observe(canvas);
      resizeCanvas();

      function getCanvasPoint(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        return { x, y };
      }

      function beginStroke(e) {
        e.preventDefault();
        const { x, y } = getCanvasPoint(e);
        drawing = true;
        currentStroke = {
          color: colorEl.value,
          size: Number(sizeEl.value),
          points: [{ x, y }],
        };
        redrawAll();
      }

      function moveStroke(e) {
        if (!drawing) return;
        e.preventDefault();
        const { x, y } = getCanvasPoint(e);
        currentStroke.points.push({ x, y });
        redrawAll();
      }

      function endStroke(e) {
        if (!drawing) return;
        e.preventDefault();
        drawing = false;
        if (currentStroke && currentStroke.points.length > 0) {
          strokes.push(currentStroke);
        }
        currentStroke = null;
        redrawAll();
      }

      // 统一采用 Pointer 事件，兼容鼠标与触控
      canvas.addEventListener('pointerdown', beginStroke);
      canvas.addEventListener('pointermove', moveStroke);
      canvas.addEventListener('pointerup', endStroke);
      canvas.addEventListener('pointercancel', endStroke);
      canvas.addEventListener('pointerleave', endStroke);

      // 防止触控滚动干扰
      canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

      clearBtn.addEventListener('click', () => {
        // 清空保持透明底，不填充背景
        strokes.length = 0;
        currentStroke = null;
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
      });

      undoBtn.addEventListener('click', () => {
        if (strokes.length > 0) {
          strokes.pop();
          redrawAll();
        }
      });

      function isEditableElement(el) {
        if (!el) return false;
        const tag = el.tagName;
        return el.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
      }

      window.addEventListener('keydown', (e) => {
        if (isEditableElement(document.activeElement)) return;
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
          e.preventDefault();
          if (strokes.length > 0) {
            strokes.pop();
            redrawAll();
          }
        }
      });

      function downloadDataURL(dataURL, filename) {
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      async function copyCanvasPNG(offCanvas) {
        return new Promise((resolve, reject) => {
          if (!offCanvas.toBlob) {
            // 回退为复制dataURL文本（有些程序不支持直接粘贴为图片）
            const dataURL = offCanvas.toDataURL('image/png');
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(dataURL).then(() => resolve('text')).catch(reject);
            } else {
              reject(new Error('Clipboard API 不可用'));
            }
            return;
          }
          offCanvas.toBlob(async (blob) => {
            if (!blob) {
              reject(new Error('生成PNG失败'));
              return;
            }
            try {
              if (navigator.clipboard && window.ClipboardItem) {
                const item = new ClipboardItem({ 'image/png': blob });
                await navigator.clipboard.write([item]);
                resolve('image');
              } else if (navigator.clipboard && navigator.clipboard.writeText) {
                // 回退为文本
                const dataURL = offCanvas.toDataURL('image/png');
                await navigator.clipboard.writeText(dataURL);
                resolve('text');
              } else {
                reject(new Error('Clipboard API 不支持图像复制'));
              }
            } catch (err) {
              reject(err);
            }
          }, 'image/png');
        });
      }

      function canvasToBlob(offCanvas) {
        return new Promise((resolve, reject) => {
          if (!offCanvas.toBlob) {
            try {
              const dataURL = offCanvas.toDataURL('image/png');
              const bin = atob(dataURL.split(',')[1]);
              const len = bin.length;
              const arr = new Uint8Array(len);
              for (let i = 0; i < len; i++) arr[i] = bin.charCodeAt(i);
              resolve(new Blob([arr], { type: 'image/png' }));
            } catch (err) {
              reject(err);
            }
            return;
          }
          offCanvas.toBlob((blob) => {
            if (!blob) {
              reject(new Error('生成PNG失败'));
              return;
            }
            resolve(blob);
          }, 'image/png');
        });
      }

      function downloadCanvasPNG(offCanvas, filename) {
        if (offCanvas.toBlob) {
          offCanvas.toBlob((blob) => {
            if (!blob) {
              const dataURL = offCanvas.toDataURL('image/png');
              downloadDataURL(dataURL, filename);
              return;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 'image/png');
        } else {
          const dataURL = offCanvas.toDataURL('image/png');
          downloadDataURL(dataURL, filename);
        }
      }

      function computeStrokeBounds() {
        if (strokes.length === 0) return null;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let maxSize = 1;
        for (const s of strokes) {
          if (s.size > maxSize) maxSize = s.size;
          for (const p of s.points) {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
          }
        }
        if (!isFinite(minX)) return null;
        const pad = Math.ceil(maxSize / 2);
        return {
          left: Math.max(0, minX - pad),
          top: Math.max(0, minY - pad),
          right: maxX + pad,
          bottom: maxY + pad,
        };
      }

      function drawStrokePath(targetCtx, stroke) {
        const pts = stroke.points;
        if (pts.length === 0) return;
        targetCtx.beginPath();
        targetCtx.moveTo(pts[0].x, pts[0].y);
        if (pts.length === 1) {
          targetCtx.lineTo(pts[0].x + 0.01, pts[0].y + 0.01); // 单点也显示为小点
        } else {
          for (let i = 1; i < pts.length; i++) {
            const p0 = pts[i - 1];
            const p1 = pts[i];
            const mx = (p0.x + p1.x) / 2;
            const my = (p0.y + p1.y) / 2;
            targetCtx.quadraticCurveTo(p0.x, p0.y, mx, my);
          }
          const last = pts[pts.length - 1];
          targetCtx.lineTo(last.x, last.y);
        }
        targetCtx.stroke();
      }

      function renderStrokes(targetCtx, scale = 1, translateX = 0, translateY = 0, absolute = false) {
        targetCtx.save();
        if (absolute) {
          // 绝对变换：用于离屏导出，避免受到现有设备像素缩放影响
          targetCtx.setTransform(scale, 0, 0, scale, translateX, translateY);
        } else {
          // 相对变换：保留现有设备像素缩放，仅做局部变换
          targetCtx.translate(translateX, translateY);
          targetCtx.scale(scale, scale);
        }
        targetCtx.lineCap = 'round';
        targetCtx.lineJoin = 'round';
        for (const s of strokes) {
          targetCtx.strokeStyle = s.color;
          targetCtx.lineWidth = s.size;
          drawStrokePath(targetCtx, s);
        }
        if (currentStroke) {
          targetCtx.strokeStyle = currentStroke.color;
          targetCtx.lineWidth = currentStroke.size;
          drawStrokePath(targetCtx, currentStroke);
        }
        targetCtx.restore();
      }

      function redrawAll() {
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        // 保持现有的设备像素缩放，只做相对重绘
        renderStrokes(ctx, 1, 0, 0, false);
      }

      function saveFullPNG() {
        const rect = canvas.getBoundingClientRect();
        const scale = Math.max(1, Number(exportScaleEl.value) || 1);
        const off = document.createElement('canvas');
        off.width = Math.max(1, Math.floor(rect.width * scale));
        off.height = Math.max(1, Math.floor(rect.height * scale));
        const offCtx = off.getContext('2d', { alpha: true });
        // 离屏导出使用绝对变换，确保清晰导出
        renderStrokes(offCtx, scale, 0, 0, true);
        const stamp = new Date().toISOString().replace(/[:.]/g, '-');
        downloadCanvasPNG(off, `signature-${stamp}.png`);
      }

      function saveTrimmedPNG() {
        if (strokes.length === 0 && !currentStroke) {
          alert('画布为空，请先签名再保存。');
          return;
        }
        const bounds = computeStrokeBounds();
        if (!bounds) {
          alert('未检测到笔迹，请重试。');
          return;
        }
        const scale = Math.max(1, Number(exportScaleEl.value) || 1);
        const w = Math.max(1, Math.floor((bounds.right - bounds.left) * scale));
        const h = Math.max(1, Math.floor((bounds.bottom - bounds.top) * scale));
        const off = document.createElement('canvas');
        off.width = w;
        off.height = h;
        const offCtx = off.getContext('2d', { alpha: true });
        // 以几何边界裁剪并重绘到离屏画布（透明背景），实现高分辨率导出
        // 离屏裁剪导出使用绝对变换
        renderStrokes(offCtx, scale, -Math.floor(bounds.left * scale), -Math.floor(bounds.top * scale), true);
        const stamp = new Date().toISOString().replace(/[:.]/g, '-');
        downloadCanvasPNG(off, `signature-trimmed-${stamp}.png`);
      }

      async function copyTrimmedToClipboard() {
        if (strokes.length === 0 && !currentStroke) {
          alert('画布为空，请先签名再复制。');
          return;
        }
        const bounds = computeStrokeBounds();
        if (!bounds) {
          alert('未检测到笔迹，请重试。');
          return;
        }
        const scale = Math.max(1, Number(exportScaleEl.value) || 1);
        const w = Math.max(1, Math.floor((bounds.right - bounds.left) * scale));
        const h = Math.max(1, Math.floor((bounds.bottom - bounds.top) * scale));
        const off = document.createElement('canvas');
        off.width = w;
        off.height = h;
        const offCtx = off.getContext('2d', { alpha: true });
        renderStrokes(offCtx, scale, -Math.floor(bounds.left * scale), -Math.floor(bounds.top * scale), true);
        try {
          const type = await copyCanvasPNG(off);
          if (type === 'image') {
            alert('已复制PNG到剪贴板，可以到其他程序直接粘贴。');
          } else {
            alert('已复制PNG的dataURL文本到剪贴板。若无法直接粘贴为图片，请使用保存PNG按钮或在系统浏览器中操作。');
          }
        } catch (err) {
          console.error(err);
          const dataURL = off.toDataURL('image/png');
          const w = window.open(dataURL, '_blank');
          if (w) {
            alert('剪贴板写入图片失败。已在新标签打开图片，可长按/右键复制。');
          } else {
            alert('剪贴板写入图片失败，且无法打开新标签。请尝试使用保存PNG按钮。');
          }
        }
      }

      async function shareTrimmedPNG() {
        if (strokes.length === 0 && !currentStroke) {
          alert('画布为空，请先签名再分享。');
          return;
        }
        const bounds = computeStrokeBounds();
        if (!bounds) {
          alert('未检测到笔迹，请重试。');
          return;
        }
        const scale = Math.max(1, Number(exportScaleEl.value) || 1);
        const w = Math.max(1, Math.floor((bounds.right - bounds.left) * scale));
        const h = Math.max(1, Math.floor((bounds.bottom - bounds.top) * scale));
        const off = document.createElement('canvas');
        off.width = w;
        off.height = h;
        const offCtx = off.getContext('2d', { alpha: true });
        renderStrokes(offCtx, scale, -Math.floor(bounds.left * scale), -Math.floor(bounds.top * scale), true);
        try {
          const blob = await canvasToBlob(off);
          const file = new File([blob], 'signature.png', { type: 'image/png' });
          if (navigator.canShare && navigator.canShare({ files: [file] })) {
            await navigator.share({ files: [file], title: '签名PNG', text: '签名PNG' });
          } else if (navigator.share) {
            // 某些浏览器不支持文件分享，但可分享链接：打开预览再分享
            const dataURL = off.toDataURL('image/png');
            await navigator.share({ title: '签名PNG', text: '签名PNG', url: dataURL });
          } else {
            const dataURL = off.toDataURL('image/png');
            const w = window.open(dataURL, '_blank');
            if (w) {
              alert('当前浏览器不支持分享文件，已打开图片预览，可手动长按保存或复制。');
            } else {
              alert('分享不可用，且无法打开新标签。请尝试使用保存PNG或复制功能。');
            }
          }
        } catch (err) {
          console.error(err);
          alert('分享失败：' + (err && err.message ? err.message : '未知错误'));
        }
      }

      saveFullBtn.addEventListener('click', saveFullPNG);
      saveTrimBtn.addEventListener('click', saveTrimmedPNG);
      copyBtn.addEventListener('click', copyTrimmedToClipboard);
      shareBtn.addEventListener('click', shareTrimmedPNG);
    </script>
  </body>
  </html>
<!-- END: 手写签名png.html -->
    </template>

    <!-- 内嵌模板：更多功能 -->
    <template id="tpl-more"><!-- BEGIN: 更多功能.html (模板) -->
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>更多功能····</title>
    <style>
      html, body { height: 100%; }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Microsoft YaHei", "PingFang SC", sans-serif; background: #ffffff; color: #222; }
      。wrap { height: 100%; display: flex; align-items: center; justify-content: center; }
      。msg { font-size: 18px; color: #555; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="msg">更多功能正在路上·····</div>
    </div>
  </body>
  </html>
<!-- END: 更多功能.html (模板) -->
    </template>

    <script>
      // 通用可扩展的标签与 iframe 切换逻辑
      const tabs = Array.from(document.querySelectorAll('.tab-btn'));
      const frames = {};
      tabs.forEach(btn => {
        const key = btn.dataset.target;
        frames[key] = document.getElementById(`frame-${key}`);
      });

      function setActive(key) {
        tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.target === key));
        Object.keys(frames).forEach(k => {
          const f = frames[k];
          if (f) f.setAttribute('aria-hidden', String(k !== key));
        });
        window.location.hash = key;
      }

      function initFrames() {
        tabs.forEach(btn => {
          const key = btn.dataset.target;
          const tpl = document.getElementById(`tpl-${key}`);
          const frame = frames[key];
          if (tpl && frame) {
            frame.srcdoc = tpl.innerHTML;
          }
          btn.addEventListener('click', () => setActive(key));
        });
        const hashKey = (location.hash || '').replace('#','');
        const initial = frames[hashKey] ? hashKey : tabs[0].dataset.target;
        setActive(initial);
      }

      document.addEventListener('DOMContentLoaded', initFrames);
    </script>
  </body>
</html>
