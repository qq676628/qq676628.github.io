<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>图片拼接工具 - Mr.Chen</title>
  <style>
    :root {
      --bg: #f7f7fa;
      --card: #ffffff;
      --text: #222;
      --muted: #666;
      --accent: #3a7afe;
      --border: #e5e7eb;
      --danger: #d14343;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Microsoft YaHei", "PingFang SC", sans-serif; background: var(--bg); color: var(--text); }
    header { padding: 8px; text-align: center; }
    header h1 { margin: 4px 0 2px; font-size: 20px; }
    header p { margin: 0; color: var(--muted); font-size: 13px; display:none; }

    .container { max-width: 1800px; margin: 0 auto; padding: 8px 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 920px) { .grid { grid-template-columns: 0.7fr 1.3fr; } }
    .column { display: flex; flex-direction: column; gap: 10px; }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    .card h2 { font-size: 16px; margin: 0; padding: 8px 12px 0; }
    .card .content { padding: 10px; }

    .uploader { border: 1px dashed var(--border); border-radius: 8px; padding: 10px; background: #fafafa; }
    .file-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
.file-row input[type="file"] { flex: 1; font-size: 16px; }
.file-row input[type="file"]::file-selector-button,
.file-row input[type="file"]::-webkit-file-upload-button {
  appearance: none;
  border: 1px solid var(--border);
  background: #f0f5ff;
  color: var(--text);
  padding: 10px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all .15s ease;
  box-shadow: 0 1px 1px rgba(0,0,0,0.04);
}
.file-row input[type="file"]::file-selector-button:hover,
.file-row input[type="file"]::-webkit-file-upload-button:hover {
  border-color: #c8ccd3;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  transform: translateY(-0.5px);
}
    .hint { font-size: 12px; color: var(--muted); }

    .canvas-wrap { position: relative; border: 2px solid var(--border); border-radius: 8px; overflow: hidden; background: #fff; }
    /* 仅等比缩小：不放大原始像素尺寸，保持比例 */
    .canvas-wrap canvas { display: block; width: auto; height: auto; max-width: 100%; max-height: 100%; }
    /* 拖拽高亮 */
    .canvas-wrap.dragover { border-color: var(--accent); box-shadow: inset 0 0 0 2px rgba(58,122,254,0.35); background: #f8fbff; }
    .overlay { position: absolute; left: 0; top: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center; }
    .overlay.hidden { display: none; }
    .overlay .hint-box { text-align: center; color: var(--muted); font-size: 13px; background: rgba(255,255,255,0.85); padding: 8px 12px; border-radius: 8px; border: 1px dashed var(--border); }
    /* 全屏拖拽提示层 */
    .page-drag-overlay { position: fixed; z-index: 9999; left: 0; top: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; background: rgba(58,122,254,0.08); }
    .page-drag-overlay .hint-box { text-align: center; color: var(--accent); font-size: 16px; background: rgba(255,255,255,0.92); padding: 12px 16px; border-radius: 10px; border: 2px dashed var(--accent); box-shadow: 0 4px 14px rgba(58,122,254,0.25); }
    .page-drag-overlay .hint-box small { display:block; color: var(--muted); margin-top: 6px; }
    .page-drag-overlay.hidden { display: none; }
    .controls { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin-top: 8px; }
    .controls label { font-size: 13px; color: var(--muted); }
    .controls .inline { display: flex; align-items: center; gap: 8px; }
    /* 去除未使用的滑块样式 */
    .btn { appearance: none; border: 1px solid var(--border); background: #fff; color: var(--text); padding: 8px 12px; border-radius: 10px; cursor: pointer; font-size: 14px; transition: all .15s ease; box-shadow: 0 1px 1px rgba(0,0,0,0.04); }
    .btn:hover { border-color: #c8ccd3; box-shadow: 0 2px 6px rgba(0,0,0,0.08); transform: translateY(-0.5px); }
    .btn:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.06); }
    .btn:focus-visible { outline: 2px solid rgba(58,122,254,0.35); outline-offset: 2px; }
    .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 2px 8px rgba(58,122,254,0.35); }
    .btn-primary:hover { filter: brightness(1.05); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-accent { border-color: var(--accent); color: var(--accent); background: #f0f5ff; }
    .btn-accent:hover { background: #e6eeff; }
    .btn-danger { background: var(--danger); color: #fff; border-color: var(--danger); }

    .settings { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 640px) { .settings { grid-template-columns: 1fr 1fr; } }
    .row { display: flex; align-items: center; gap: 8px; }
    .row input[type="text"] { flex: 1; padding: 8px 10px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; }
    .row .note { font-size: 12px; color: var(--muted); }

    .footer { display: flex; flex-direction: column; gap: 8px; }
    @media (min-width: 640px) { .footer { flex-direction: row; align-items: center; } }
    .msg { font-size: 12px; color: var(--muted); }

    .preview-card { margin-top: 12px; display: flex; flex-direction: column; }
    .preview-card h3 { margin: 0; padding: 12px 12px 0; font-size: 14px; color: var(--muted); }
    .size-line { font-size: 12px; color: var(--muted); padding: 0 12px 12px; }
    /* 右侧预览固定高度，内部自适应缩放 */
    .preview-card .content { display: flex; flex-direction: column; height: 100%; }
    .preview-card .canvas-wrap { flex: 1; background: #fafafa; min-height: 0; display: flex; align-items: center; justify-content: center; }
    .preview-card .canvas-wrap canvas { max-width: 100%; max-height: 100%; }
  </style>
</head>
<body>
  <header>
    <!-- <h1>图片拼接工具</h1> -->
    <p>上传两张图片，支持裁切与旋转；按裁剪后尺寸动态拼接白底JPG并限制≤500KB。</p>
  </header>

  <div class="container">
    <div class="grid">
      <div class="column" id="leftColumn">
      <!-- 左侧编辑器：图片1 -->
      <section class="card" id="editor1">
        <h2>图片一</h2>
        <div class="content">
          <div class="uploader">
            <div class="file-row">
              <input type="file" id="file1" accept="image/*" />
              
            </div>
          </div>
          <div class="canvas-wrap" style="margin-top:6px;">
            <canvas id="canvas1" width="480" height="280"></canvas>
            <div class="overlay" id="overlay1">
              <div class="hint-box">
                <div><strong>拖拽图片到此处</strong></div>
                <div>或点击上方选择</div>
              </div>
            </div>
          </div>
          <div class="controls">
            <div class="inline">
              <label>旋转：当前 <span id="rotVal1">0°</span></label>
<button class="btn btn-accent" id="rotateLeft1">向左旋转90°</button>
<button class="btn btn-accent" id="rotateRight1">向右旋转90°</button>
            </div>
            <button class="btn" id="clearCrop1">清除裁切</button>
          </div>
          
        </div>
      </section>

      <!-- 右侧编辑器：图片2 -->
      <section class="card" id="editor2">
        <h2>图片二</h2>
        <div class="content">
          <div class="uploader">
            <div class="file-row">
              <input type="file" id="file2" accept="image/*" />
              
            </div>
          </div>
          <div class="canvas-wrap" style="margin-top:6px;">
            <canvas id="canvas2" width="480" height="280"></canvas>
            <div class="overlay" id="overlay2">
              <div class="hint-box">
                <div><strong>拖拽图片到此处</strong></div>
                <div>或点击上方选择</div>
              </div>
            </div>
          </div>
          <div class="controls">
            <div class="inline">
              <label>旋转：当前 <span id="rotVal2">0°</span></label>
<button class="btn btn-accent" id="rotateLeft2">向左旋转90°</button>
<button class="btn btn-accent" id="rotateRight2">向右旋转90°</button>
            </div>
            <button class="btn" id="clearCrop2">清除裁切</button>
          </div>
          
        </div>
      </section>
      </div>

      <div class="column">
        <!-- 右侧：拼接预览与下载 -->
        <section class="card preview-card" id="finalCard" style="margin-top:0;">
          <div class="content">
            <div class="settings">
              <div class="row">
                <label for="filename">图片存储名称：</label>
                <input type="text" id="filename" placeholder="拼接图" value="客户姓名 - " />
              </div>
            </div>
            <div class="canvas-wrap" style="margin-top:6px;">
            <canvas id="finalCanvas" width="800" height="600"></canvas>
            </div>
            <div class="footer" style="margin-top:8px;">
              <button class="btn btn-primary" id="downloadBtn" disabled>下载JPG（≤500KB）</button>
              <span class="msg" id="statusMsg">请先上传两张图片并进行裁切/旋转设置。</span>
            </div>
            <div class="size-line" id="sizeLine">当前估算大小：--</div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <!-- 全屏拖拽提示层 -->
  <div id="pageDragOverlay" class="page-drag-overlay hidden">
    <div class="hint-box">
      <div><strong>拖拽图片到页面</strong></div>
      <small>请将图片拖拽到“图片一”或“图片二”的预览区</small>
    </div>
  </div>

  <script>
    // 配置
    const MAX_BYTES = 500 * 1024;
    // 固定边距与间距（无需交互）
    const MARGIN_LR = 40; // 左右边距
    const MARGIN_TB = 40; // 上下边距
    const GAP_VB = 20;    // 两图上下间距

    // 同步右侧预览卡片高度到左列总高度，保证对齐并固定
    function syncRightHeight(){
      const left = document.getElementById('leftColumn');
      const right = document.getElementById('finalCard');
      if (!left || !right) return;
      const h = Math.round(left.getBoundingClientRect().height);
      right.style.height = h + 'px';
    }
    window.addEventListener('load', syncRightHeight);
    window.addEventListener('resize', syncRightHeight);

    // 工具函数
    function dataUrlSizeBytes(dataUrl) {
      try {
        const base64 = dataUrl.split(',')[1] || '';
        return Math.ceil(base64.length * 0.75); // base64长度≈字节数*4/3
      } catch (e) { return Infinity; }
    }
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    // 图像编辑器对象
    function createEditor(cfg) {
      const fileInput = document.getElementById(cfg.fileId);
      const canvas = document.getElementById(cfg.canvasId);
      const ctx = canvas.getContext('2d');
      const dropZone = canvas.parentElement; // 预览区域作为拖拽目标
      const overlay = document.getElementById(cfg.overlayId);
      // 不再使用独立的DOM覆盖层，改为在canvas上绘制裁剪框，避免CSS缩放造成坐标误差
      const rotateVal = document.getElementById(cfg.rotateValId);
      const rotateLeftBtn = document.getElementById(cfg.rotateLeftId);
      const rotateRightBtn = document.getElementById(cfg.rotateRightId);
      const clearCropBtn = document.getElementById(cfg.clearCropId);

      const state = {
        img: null,
        loaded: false,
        angle: 0,
        // 裁切基于原始方向的图像坐标
        crop: null, // {x,y,w,h}
        // 预览绘制信息
        draw: { scale: 1, offsetX: 0, offsetY: 0, centerX: 0, centerY: 0, angleRad: 0 }
      };

      // 统一的文件加载函数（用于文件选择与拖拽）
      function loadFile(file){
        if (!file) return;
        const name = (file.name || '').toLowerCase();
        const isImageViaType = !!file.type && file.type.startsWith('image/');
        const isImageViaName = /\.(png|jpe?g|gif|bmp|webp|heic|heif|tif|tiff|jfif)$/i.test(name);
        if (!isImageViaType && !isImageViaName) {
          // 仍尝试加载，部分浏览器拖拽时 file.type 为空
          // 若确实不是图片，onerror 会提示
        }
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          state.img = img;
          state.loaded = true;
          state.crop = null;
          state.angle = 0;
          rotateVal.textContent = '0°';
          drawPreview();
          updateFinal();
          if (overlay) overlay.classList.add('hidden');
          URL.revokeObjectURL(url);
        };
        img.onerror = ()=>{ alert('图片加载失败，文件可能不是受支持的图片格式。'); URL.revokeObjectURL(url); };
        img.src = url;
      }

      function drawPreview() {
        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        if (!state.loaded) return;
        const iw = state.img.naturalWidth;
        const ih = state.img.naturalHeight;
        const cw = canvas.width, ch = canvas.height;
        const ang = (state.angle||0) * Math.PI/180;
        const rotW = (Math.abs(state.angle)%180===0) ? iw : ih;
        const rotH = (Math.abs(state.angle)%180===0) ? ih : iw;
        const scale = Math.min(cw/rotW, ch/rotH);
        state.draw.scale = scale;
        state.draw.centerX = cw/2;
        state.draw.centerY = ch/2;
        state.draw.angleRad = ang;
        state.draw.offsetX = 0; // 不再使用简单偏移，改用中心点
        state.draw.offsetY = 0;
        ctx.save();
        ctx.translate(state.draw.centerX, state.draw.centerY);
        ctx.rotate(ang);
        ctx.drawImage(state.img, -iw/2*scale, -ih/2*scale, iw*scale, ih*scale);
        ctx.restore();

        // 画裁切选区（预览层由CSS承载边框，这里用半透明填充）
        if (state.crop) {
          // 将裁剪矩形四个角旋转后绘制为多边形，以匹配预览旋转
          const ang = state.draw.angleRad;
          const s = state.draw.scale;
          const cx = state.draw.centerX;
          const cy = state.draw.centerY;
          // 原图坐标下四角（以图像中心为参考）
          const x0 = state.crop.x - iw/2;
          const y0 = state.crop.y - ih/2;
          const x1 = x0 + state.crop.w;
          const y1 = y0 + state.crop.h;
          const corners = [
            {x:x0, y:y0},
            {x:x1, y:y0},
            {x:x1, y:y1},
            {x:x0, y:y1}
          ].map(p=>{
            const xr = p.x * Math.cos(ang) - p.y * Math.sin(ang);
            const yr = p.x * Math.sin(ang) + p.y * Math.cos(ang);
            return { x: cx + xr*s, y: cy + yr*s };
          });
          // 记录画布上的裁剪框四角用于命中测试
          state.draw.cropCanvasCorners = corners;
          ctx.save();
          ctx.strokeStyle = '#3a7afe';
          ctx.setLineDash([6,4]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(corners[0].x, corners[0].y);
          for (let i=1;i<corners.length;i++) ctx.lineTo(corners[i].x, corners[i].y);
          ctx.closePath();
          ctx.stroke();
          ctx.fillStyle = 'rgba(58,122,254,0.15)';
          ctx.fill();
          ctx.restore();

          // 绘制四个角的调整手柄
          ctx.save();
          ctx.fillStyle = '#3a7afe';
          for (const c of corners) {
            ctx.beginPath();
            ctx.arc(c.x, c.y, 5, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }
      }

      // 事件：文件选择
      fileInput.addEventListener('change', (e)=>{
        const file = e.target.files && e.target.files[0];
        loadFile(file);
      });

      // 拖拽上传到预览区域
      ['dragenter','dragover'].forEach(evtName => {
        dropZone.addEventListener(evtName, (e)=>{
          e.preventDefault();
          e.stopPropagation();
          dropZone.classList.add('dragover');
          if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
        });
      });
      dropZone.addEventListener('dragleave', (e)=>{
        dropZone.classList.remove('dragover');
      });
      dropZone.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        const dt = e.dataTransfer;
        if (!dt) return;
        let file = dt.files && dt.files[0];
        if (!file && dt.items && dt.items.length) {
          for (const it of dt.items) {
            if (it.kind === 'file') { file = it.getAsFile(); break; }
          }
        }
        loadFile(file);
      });

      // 同步在 canvas 上也绑定拖拽事件，提升兼容性
      ['dragenter','dragover'].forEach(evtName => {
        canvas.addEventListener(evtName, (e)=>{
          e.preventDefault();
          e.stopPropagation();
          dropZone.classList.add('dragover');
          if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
        });
      });
      canvas.addEventListener('dragleave', (e)=>{
        dropZone.classList.remove('dragover');
      });
      canvas.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        const dt = e.dataTransfer;
        if (!dt) return;
        let file = dt.files && dt.files[0];
        if (!file && dt.items && dt.items.length) {
          for (const it of dt.items) {
            if (it.kind === 'file') { file = it.getAsFile(); break; }
          }
        }
        loadFile(file);
      });

      // 事件：旋转（按钮，每次90°）
      rotateLeftBtn.addEventListener('click', ()=>{
        state.angle = ((state.angle - 90) % 360 + 360) % 360;
        rotateVal.textContent = state.angle + '°';
        drawPreview();
        updateFinal();
      });
      rotateRightBtn.addEventListener('click', ()=>{
        state.angle = (state.angle + 90) % 360;
        rotateVal.textContent = state.angle + '°';
        drawPreview();
        updateFinal();
      });

      // 事件：清除裁切
      clearCropBtn.addEventListener('click', ()=>{
        state.crop = null;
        drawPreview();
        updateFinal();
      });

      // 裁切选择（鼠标/触控）
      let selecting = false; let startX=0, startY=0; let curX=0, curY=0;
      let draggingCrop = false; let resizingCropIdx = -1; let lastImgPos = null;
      function toCanvasPos(evt){
        const rect = canvas.getBoundingClientRect();
        const clientX = (evt.touches ? evt.touches[0].clientX : evt.clientX);
        const clientY = (evt.touches ? evt.touches[0].clientY : evt.clientY);
        const xCss = clientX - rect.left;
        const yCss = clientY - rect.top;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {x: xCss * scaleX, y: yCss * scaleY};
      }
      function toImagePos(cx, cy){
        // 将画布点转换为原图坐标（考虑旋转与缩放）
        const ang = state.draw.angleRad;
        const s = state.draw.scale;
        const cx0 = state.draw.centerX;
        const cy0 = state.draw.centerY;
        // 以画布中心为原点
        const dx = cx - cx0;
        const dy = cy - cy0;
        // 逆旋转
        const ixr = dx * Math.cos(-ang) - dy * Math.sin(-ang);
        const iyr = dx * Math.sin(-ang) + dy * Math.cos(-ang);
        // 去缩放并转换到原图左上角坐标系
        const ix = ixr / s + state.img.naturalWidth/2;
        const iy = iyr / s + state.img.naturalHeight/2;
        return { x: ix, y: iy };
      }
      function insideImage(cx, cy){
        const p = toImagePos(cx, cy);
        return p.x>=0 && p.y>=0 && p.x<=state.img.naturalWidth && p.y<=state.img.naturalHeight;
      }

      function hitTestHandle(cx, cy){
        const corners = state.draw.cropCanvasCorners || [];
        let idx = -1; let best = 1e9;
        for (let i=0;i<corners.length;i++){
          const dx = cx - corners[i].x; const dy = cy - corners[i].y;
          const d = Math.hypot(dx, dy);
          if (d < best) { best = d; idx = i; }
        }
        return best <= 12 ? idx : -1;
      }

      function pointInsideCrop(cx, cy){
        const p = toImagePos(cx, cy);
        if (!state.crop) return false;
        const x0 = state.crop.x, y0 = state.crop.y;
        const x1 = x0 + state.crop.w, y1 = y0 + state.crop.h;
        return p.x>=x0 && p.x<=x1 && p.y>=y0 && p.y<=y1;
      }

      function beginSelect(evt){
        if(!state.loaded) return;
        const pc = toCanvasPos(evt);
        // 有裁剪框时：优先命中角手柄或内部拖动
        if (state.crop) {
          const handle = hitTestHandle(pc.x, pc.y);
          if (handle >= 0) { resizingCropIdx = handle; lastImgPos = toImagePos(pc.x, pc.y); evt.preventDefault(); return; }
          if (pointInsideCrop(pc.x, pc.y)) { draggingCrop = true; lastImgPos = toImagePos(pc.x, pc.y); evt.preventDefault(); return; }
        }
        // 否则开始新的框选
        selecting = true; startX=pc.x; startY=pc.y; curX=pc.x; curY=pc.y; evt.preventDefault();
      }
      function moveSelect(evt){
        if(!state.loaded) return;
        const pc = toCanvasPos(evt);
        if (resizingCropIdx >= 0 && state.crop) {
          const imgP = toImagePos(pc.x, pc.y);
          const iw = state.img.naturalWidth, ih = state.img.naturalHeight;
          const c = state.crop;
          const cornersImg = [
            {x:c.x, y:c.y},
            {x:c.x + c.w, y:c.y},
            {x:c.x + c.w, y:c.y + c.h},
            {x:c.x, y:c.y + c.h}
          ];
          const oppIndex = [2,3,0,1][resizingCropIdx];
          const opp = cornersImg[oppIndex];
          const rx = clamp(Math.min(imgP.x, opp.x), 0, iw);
          const ry = clamp(Math.min(imgP.y, opp.y), 0, ih);
          const rw = clamp(Math.abs(imgP.x - opp.x), 1, iw - rx);
          const rh = clamp(Math.abs(imgP.y - opp.y), 1, ih - ry);
          state.crop = { x: rx, y: ry, w: rw, h: rh };
          drawPreview(); evt.preventDefault(); return;
        }
        if (draggingCrop && state.crop) {
          const imgP = toImagePos(pc.x, pc.y);
          const dx = imgP.x - lastImgPos.x; const dy = imgP.y - lastImgPos.y; lastImgPos = imgP;
          const iw = state.img.naturalWidth, ih = state.img.naturalHeight;
          const nx = clamp(state.crop.x + dx, 0, iw - state.crop.w);
          const ny = clamp(state.crop.y + dy, 0, ih - state.crop.h);
          state.crop.x = nx; state.crop.y = ny;
          drawPreview(); evt.preventDefault(); return;
        }
        if (!selecting) return;
        curX=pc.x; curY=pc.y; drawPreview(); const x=Math.min(startX,curX), y=Math.min(startY,curY), w=Math.abs(curX-startX), h=Math.abs(curY-startY); ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle='#3a7afe'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); ctx.fillStyle='rgba(58,122,254,0.12)'; ctx.fillRect(x,y,w,h); ctx.restore(); evt.preventDefault();
      }
      function endSelect(evt){
        if(!state.loaded) return;
        if (resizingCropIdx >= 0 || draggingCrop) { resizingCropIdx = -1; draggingCrop = false; updateFinal(); evt.preventDefault(); return; }
        if (!selecting) return;
        selecting=false; const x=Math.min(startX,curX), y=Math.min(startY,curY), w=Math.abs(curX-startX), h=Math.abs(curY-startY); // 转为图像坐标
        const p1 = toImagePos(x,y); const p2 = toImagePos(x+w, y+h);
        const rx = clamp(Math.min(p1.x,p2.x),0,state.img.naturalWidth);
        const ry = clamp(Math.min(p1.y,p2.y),0,state.img.naturalHeight);
        const rw = clamp(Math.abs(p2.x-p1.x),0,state.img.naturalWidth-rx);
        const rh = clamp(Math.abs(p2.y-p1.y),0,state.img.naturalHeight-ry);
        if (rw>10 && rh>10 && insideImage(x,y) && insideImage(x+w,y+h)) {
          state.crop = { x: rx, y: ry, w: rw, h: rh };
        }
        drawPreview(); updateFinal(); evt.preventDefault(); }

      canvas.addEventListener('mousedown', beginSelect);
      canvas.addEventListener('mousemove', moveSelect);
      window.addEventListener('mouseup', endSelect);
      canvas.addEventListener('touchstart', beginSelect, {passive:false});
      canvas.addEventListener('touchmove', moveSelect, {passive:false});
      canvas.addEventListener('touchend', endSelect);

      // 初始绘制空白
      drawPreview();
      if (overlay) overlay.classList.toggle('hidden', !!state.loaded);

      return { state, drawPreview };
    }

    // 创建两个编辑器
    const ed1 = createEditor({ fileId:'file1', canvasId:'canvas1', overlayId:'overlay1', rotateValId:'rotVal1', rotateLeftId:'rotateLeft1', rotateRightId:'rotateRight1', clearCropId:'clearCrop1' });
    const ed2 = createEditor({ fileId:'file2', canvasId:'canvas2', overlayId:'overlay2', rotateValId:'rotVal2', rotateLeftId:'rotateLeft2', rotateRightId:'rotateRight2', clearCropId:'clearCrop2' });

    const finalCanvas = document.getElementById('finalCanvas');
    const fctx = finalCanvas.getContext('2d');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusMsg = document.getElementById('statusMsg');
    const sizeLine = document.getElementById('sizeLine');
    const filenameInput = document.getElementById('filename');

    function processImage(editor) {
      if (!editor.state.loaded) return null;
      const img = editor.state.img;
      const angle = (editor.state.angle || 0) * Math.PI/180;
      const crop = editor.state.crop || { x:0, y:0, w: img.naturalWidth, h: img.naturalHeight };

      // 1) 先裁切
      const cut = document.createElement('canvas');
      cut.width = Math.max(1, Math.round(crop.w));
      cut.height = Math.max(1, Math.round(crop.h));
      const cctx = cut.getContext('2d');
      cctx.imageSmoothingQuality = 'high';
      cctx.drawImage(img, -crop.x, -crop.y);

      // 2) 再旋转，生成紧致边界
      if (Math.abs(angle) > 1e-3) {
        const w = cut.width, h = cut.height;
        const cos = Math.abs(Math.cos(angle)), sin = Math.abs(Math.sin(angle));
        const rw = Math.max(1, Math.floor(w*cos + h*sin));
        const rh = Math.max(1, Math.floor(w*sin + h*cos));
        const rot = document.createElement('canvas');
        rot.width = rw; rot.height = rh;
        const rctx = rot.getContext('2d');
        rctx.imageSmoothingQuality = 'high';
        rctx.translate(rw/2, rh/2);
        rctx.rotate(angle);
        rctx.drawImage(cut, -w/2, -h/2);
        return rot;
      }
      return cut;
    }

    function composeA4AndEstimate() {
      const items = [];
      const p1 = ed1.state.loaded ? processImage(ed1) : null;
      const p2 = ed2.state.loaded ? processImage(ed2) : null;
      if (p1) items.push(p1);
      if (p2) items.push(p2);

      if (items.length === 0) {
        finalCanvas.width = 600; finalCanvas.height = 400;
        fctx.fillStyle = '#ffffff';
        fctx.fillRect(0,0,finalCanvas.width, finalCanvas.height);
        downloadBtn.disabled = true;
        statusMsg.textContent = '请上传图片后预览拼接效果。';
        sizeLine.textContent = '当前估算大小：--';
        syncRightHeight();
        return null;
      }

      const marginLR = MARGIN_LR;
      const marginTB = MARGIN_TB;
      const gapVB = GAP_VB;

      // 以图片一的最大边为基准统一尺寸（避免大小不一致）
      const refMax = p1 ? Math.max(p1.width, p1.height) : Math.max(items[0].width, items[0].height);
      const scaled = items.map(it => {
        const s = refMax / Math.max(it.width, it.height);
        return {
          w: Math.max(1, Math.round(it.width * s)),
          h: Math.max(1, Math.round(it.height * s)),
          s,
          src: it
        };
      });

      // 计算画布尺寸（左右居中对齐、上下间距）
      const width = Math.max(...scaled.map(it => it.w)) + marginLR*2;
      let height = marginTB * 2;
      for (let i=0;i<scaled.length;i++) height += scaled[i].h;
      height += gapVB * Math.max(0, scaled.length - 1);

      finalCanvas.width = Math.max(1, Math.floor(width));
      finalCanvas.height = Math.max(1, Math.floor(height));
      fctx.fillStyle = '#ffffff';
      fctx.fillRect(0,0,finalCanvas.width, finalCanvas.height);

      let y = marginTB;
      for (let i=0;i<scaled.length;i++) {
        const it = scaled[i];
        const x = Math.floor((finalCanvas.width - it.w)/2);
        fctx.drawImage(it.src, x, y, it.w, it.h);
        y += it.h + (i < scaled.length-1 ? gapVB : 0);
      }

      // 估算大小（以质量0.9预估）
      const previewUrl = finalCanvas.toDataURL('image/jpeg', 0.9);
      const bytes = dataUrlSizeBytes(previewUrl);
      sizeLine.textContent = `当前估算大小（q=0.9）：${(bytes/1024).toFixed(1)}KB`;
      downloadBtn.disabled = false;
      statusMsg.textContent = `预览已更新（已加载${items.length}张），可点击下载按钮导出（自动≤500KB）。`;
      syncRightHeight();
      return { previewUrl, bytes };
    }

    function updateFinal(){ composeA4AndEstimate(); }

    // 下载逻辑：限制≤500KB，优先降低质量，其次缩小画布
    downloadBtn.addEventListener('click', ()=>{
      composeA4AndEstimate();
      let quality = 0.92;
      let url = finalCanvas.toDataURL('image/jpeg', quality);
      let bytes = dataUrlSizeBytes(url);
      let attempts = 0;
      while (bytes > MAX_BYTES && quality > 0.40 && attempts < 10) {
        quality -= 0.08; attempts++;
        url = finalCanvas.toDataURL('image/jpeg', quality);
        bytes = dataUrlSizeBytes(url);
      }
      // 若质量降低仍超限，则缩放画布
      let shrinkSteps = 0;
      while (bytes > MAX_BYTES && shrinkSteps < 8) {
        const scale = 0.88; // 逐步缩小
        const sw = Math.max(200, Math.floor(finalCanvas.width * scale));
        const sh = Math.max(200, Math.floor(finalCanvas.height * scale));
        const tmp = document.createElement('canvas');
        tmp.width = sw; tmp.height = sh;
        const tctx = tmp.getContext('2d');
        tctx.imageSmoothingQuality = 'high';
        tctx.drawImage(finalCanvas, 0, 0, sw, sh);
        finalCanvas.width = sw; finalCanvas.height = sh;
        fctx.drawImage(tmp, 0, 0);
        url = finalCanvas.toDataURL('image/jpeg', quality);
        bytes = dataUrlSizeBytes(url);
        shrinkSteps++;
      }

      if (bytes > MAX_BYTES) {
        alert('在保持合理清晰度下仍无法压缩到500KB以内，请尝试减小裁切范围或使用更低分辨率图片。');
        return;
      }

      const name = (filenameInput.value || '拼接图').replace(/[\\/:*?"<>|]/g,'').trim() || '拼接图';
      const a = document.createElement('a');
      a.href = url;
      a.download = name + '.jpg';
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    // 初次渲染
    updateFinal();
    // 全局拦截与提示层控制
    const pageDragOverlay = document.getElementById('pageDragOverlay');
    let pageDragCount = 0;
    function showPageOverlay(){ if (pageDragOverlay) pageDragOverlay.classList.remove('hidden'); }
    function hidePageOverlay(){ if (pageDragOverlay) pageDragOverlay.classList.add('hidden'); }

    window.addEventListener('dragenter', (e)=>{
      pageDragCount++;
      showPageOverlay();
      e.preventDefault();
    }, false);
    window.addEventListener('dragover', (e)=>{
      showPageOverlay();
      if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
      e.preventDefault();
    }, false);
    window.addEventListener('dragleave', (e)=>{
      pageDragCount = Math.max(0, pageDragCount - 1);
      if (pageDragCount === 0) hidePageOverlay();
      e.preventDefault();
    }, false);
    window.addEventListener('drop', (e)=>{
      hidePageOverlay();
      pageDragCount = 0;
      e.preventDefault(); // 防止页面直接打开文件
    }, false);
    window.addEventListener('dragend', ()=>{ hidePageOverlay(); pageDragCount = 0; }, false);
  </script>
</body>
</html>